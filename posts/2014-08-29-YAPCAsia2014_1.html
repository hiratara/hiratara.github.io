<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Born in Tomakomai city - 今日は YAPC::Asia Tokyo 2014 の１日目です</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        
        <!-- Google Analytics tracking codes -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-7637699-4', 'hiratara.github.io');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <!-- facebook SDK -->
        <div id="fb-root"></div>
        <script>(function(d, s, id) {
          var js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s); js.id = id;
          js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=100848266724416";
          fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script>

        <div id="header">
            <div id="logo">
                <a href="../">Born in Tomakomai city</a>
            </div>
            <div id="navigation">
                <a href="../">Top</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1><a href="../posts/2014-08-29-YAPCAsia2014_1.html">今日は YAPC::Asia Tokyo 2014 の１日目です</a></h1>

<div class="info">
    Posted on August 29, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-08-29-YAPCAsia2014_1.html" data-text="今日は YAPC::Asia Tokyo 2014 の１日目です" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-08-29-YAPCAsia2014_1.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<p>今日からが<a href="http://yapcasia.org/">本番</a>です。これから会場に入ります。</p>
<p>本日も一部の内容は <a href="http://gihyo.jp/news/report/01/yapcasia2014/0001">gihyo.jpさん</a> にも掲載していますので、併せてご覧ください。</p>
<h1 id="オープニング-yusukebeさん">オープニング / yusukebeさん</h1>
<ul>
<li>みなさんが作る会です</li>
<li>JPAの“和田”さんです</li>
<li>“There is MORE THAN ONE WAY to enjoy it!”</li>
<li>無限コーヒーあるよ！ かき氷もレッドブルも
<ul>
<li>スピーカーと話して欲しい</li>
<li>仕掛けは用意したので、みなさんで交流してください</li>
</ul></li>
<li>イベントホール以外飲食禁止</li>
<li>ポータブルWifiの電源はOFFに！</li>
<li>同時翻訳あり。機械は無くさないように</li>
<li>ベストトークの投票してね</li>
<li>ハッシュタグは <a href="https://twitter.com/search?q=%23yapcasia">#yapcasia</a> 。ブログもね！</li>
</ul>
<h1 id="satoshi-suzukiさんインフラエンジニア狭義は死んだ">Satoshi Suzukiさん「インフラエンジニア(狭義)は死んだ 」</h1>
<ul>
<li>プログラミングスキルのないエンジニアは死ぬのか</li>
<li>フルスタックエンジニアになろうという話ではない</li>
<li>開発についていけない人がなるもの？
<ul>
<li>コードを書かないイメージが持たれていることが多い</li>
</ul></li>
<li>2年くらい考えて色々やってみた
<ul>
<li>2008年から、2年くらい金融系の仕事をやっていた</li>
<li>C++、Java、PHP、で挫折 → 思い直した、という話</li>
</ul></li>
<li>インフラエンジニアとは？
<ul>
<li>システムスタック: データセンタ、電源、ネットワーク、筐体、OS、データストア、言語、アプリ(サーバ、WEB)、フロント</li>
<li>インフラエンジニアは筐体周りまで？ OSとデータストアくらいまで？ → 多様</li>
<li>WEBサービスの開発現場の人が今日のトークの対象</li>
</ul></li>
<li>インフラエンジニアの今後
<ul>
<li>運用をデータホテル、ハートビーツなど、外部にお任せ。あまりデータセンターに行かない</li>
<li>AWS、GCEなど、クラウドの理由。監視など、基本的なやることは変わらない</li>
<li>ソフトウェアの力で解決できることが拡大した</li>
<li>Nagios exchenge にプラグインが公開されている → 書けないと拡張できない</li>
<li>Fluentd → これも拡張を書く必要あり。Ruby以外でも拡張できる</li>
<li>Immutable Infrastructure, Disposable Infrastructure, Infrastructure as a Code → ソフトウェアの力</li>
<li>コードを書けないインフラエンジニアはダメなのでは</li>
</ul></li>
<li>Operation Engineers Casual Talks という勉強会をやった
<ul>
<li>tagomorisさん「自称は自意識に影響を与える、解決すべきことはなにか、分業は不可能、問題はコードで解決」(ほげエンジニアの定義について、より)</li>
<li>fujiwaraさん「コード書かないで解決できるならその方がいい。書くほど当然バグが出る」(枕を高くして寝る話、より)</li>
<li>パネルディスカッション「問題は何かを考察するのが大事。必要ならコード読み書きする」</li>
</ul></li>
<li>ya*poさん「インタネットに関わるエンジニアでインフラかコードがわからないのはまずい」
<ul>
<li>できる部分から実行していく</li>
<li>ApacheやMySQLのソースコードをいきなり触るより、解決できる問題から</li>
</ul></li>
<li>実際に手を動かせるかが大事
<ul>
<li>名称にまとわりつく先入観を捨てる</li>
<li>「ooエンジニアはxxをしない」という先入観がまずい</li>
<li>自分には関係ないことなんだ、と思ってはいけない</li>
</ul></li>
<li>どのように習得したのか
<ul>
<li>入門書レベルまでは本などで自力で</li>
<li>とにかく書く → Fluentdのout_exec_filterでPerlのコードを使った</li>
<li>業務で、既存システムをどんどん書き換えた</li>
<li>とにかく読む → CloudForecast, GrowthForecast, HRForecast, Yabitz, Whada, Fluentd</li>
<li>言語が違っても設計などが参考になる</li>
<li>身近に作者が多かったのもよかった</li>
</ul></li>
<li>コードのアドバイスをもらえた
<ul>
<li>コメントを適切に。期待する入力と戻り値</li>
<li>冗長でもわかる名前をつける</li>
<li>「xxしてからooするやつ」という名前になると、分割したほうがいいという目安</li>
</ul></li>
<li>教わるときに気をつけること
<ul>
<li>諸先輩方の言うことは素直に聞く</li>
<li>盲信するのもよくない(「過去の自分は他人」と言われた)</li>
</ul></li>
<li>fluent–plugin-flattenとrewriteのバグ修正をやらせてもらった
<ul>
<li>コーディングスタイルなどのアドバイスを受けた</li>
</ul></li>
<li>Serverspecの機能追加のpull-reqを送った
<ul>
<li>テストの落ちるpull-reqを送ってはいけないという教訓を得た</li>
</ul></li>
<li>ソースコードリーディング会
<ul>
<li>プロダクションコードの実装者を呼んで、解説してもらいながらコードを読む</li>
<li>当事者意識が芽生えるのが利点</li>
</ul></li>
<li>仲間を増やす
<ul>
<li>仲間に恵まれた → インフラにも精通したソフトウェアエンジニアなど</li>
<li>刺激を受けられる → インフラエンジニアから開発者をするようになった方々</li>
<li>まずはブログを書く、勉強会で発表する、などして名前を知ってもらうといい</li>
</ul></li>
<li>まとめ: やればできる</li>
<li>質疑応答
<ul>
<li>Q. インフラとアプリの領域かぶるSQLの部分について協業とかの仕方は？</li>
<li>A. お互いがお互いの領域を知るべき。遅いというだけでなく、実装を知ってアドバイスする</li>
<li>Q. 逆にアプリエンジニアの人に望むことは？</li>
<li>A. 前職ではコミュニケーションが難しいことがあった。アプリの人もインフラを知るといい</li>
</ul></li>
</ul>
<h1 id="daisuke-makiさんgo-for-perl-mongers">Daisuke Makiさん「Go For Perl Mongers」</h1>
<ul>
<li>みんなで発声練習してください「YAPC大好き！」</li>
<li>Go を初めて1年弱。10万行くらい書いた
<ul>
<li>最初の4万行でgoの落とし穴にかなりハマった</li>
</ul></li>
<li>質問は話の途中か廊下、Twitterなどで</li>
<li>Go は LLっぽいCである
<ul>
<li>LLののりを引きずるとGoが嫌いになる</li>
<li>設計、考え方など、全く違うメンタリティで</li>
</ul></li>
<li>例外
<ul>
<li>Goに例外はない</li>
<li>panic()とrecover()は本当にどうにもならない時のみ</li>
</ul></li>
<li>オブジェクト(継承)なんてない
<ul>
<li>オーバーライドしたメソッド呼び出しに見えるけど、違う</li>
</ul></li>
<li>GoroutineはPOSIXスレッドではない
<ul>
<li>killもwaitpidもできない</li>
<li>Goroutineは何百万個作ってもよい</li>
<li>非同期処理に精通していると、同期処理は書きやすい</li>
</ul></li>
<li>例外とエラーについて
<ul>
<li>panic()になったら、ランタイムがどういう状態にあるのか保証できない(メモリエラーなど)</li>
<li>早めにエラー処理(return)し、必ず呼び元で確認する</li>
<li>複数の戻り値でerrorを返す。 <code>return i, nil</code></li>
<li><code>if err != nil {</code> を見たらエラー処理だと思えるようになる。流儀に沿ったほうがいい</li>
<li><code>panic</code>は本当に復帰できない場合のみ</li>
<li><code>recover</code>は本当に大丈夫だとわかってる<code>panic</code>に対してのみ</li>
<li><code>fmt.Errorf()</code> エラーメッセージは小文字で始めないと怒られる</li>
<li><code>fmt</code> 「フント」と読まないとgoの人に怒られる</li>
</ul></li>
<li>Goでの構造体設計
<ul>
<li>Cの構造体チック</li>
<li>オブジェクトはない。レシーバとメソッドはある。継承はない</li>
<li>親からフィールドやメソッドをもらうことができない</li>
<li>呼び出したいオブジェクトを埋め込んで、呼び出す</li>
<li>無名埋め込みができる。あたかも継承したように見える
<ul>
<li>が、移譲。レシーバが子クラスにならない</li>
<li><code>child.printReceiver</code> と <code>child.Base.printReceiver</code> は匿名にしても同じ意味</li>
</ul></li>
<li>インタフェース中心にする。小さい部品を作ってmix-inすることで再利用</li>
<li>インタフェースを定義し、埋め込みでそれを満たす(MooseのRole)</li>
<li>Genericsはあきらめましょう。公式な答え「考えてもいい」</li>
<li>APIを考える→「草食動物」ではなく「草を食べる、ことができるもの」</li>
<li>go-stf-server はその苦闘の歴史なので、興味があれば</li>
</ul></li>
<li>並列の道具揃ってる
<ul>
<li>goroutineはスレッド、channelはスレッド間通信</li>
<li>どのスレッドでいつ実行されるか不明</li>
<li>回収する必要はないが、同期しないとリソースの開放に問題</li>
<li>goroutineの停止、終了を待ったりなど、一切の制御は不能</li>
<li>channelを使って同機を獲る <code>defer</code> の中でチャネルに送ると、終了を検知できる</li>
<li><code>defer</code> はgoroutineの終了を待たないと終わらない</li>
<li>goroutineを停止させるには、チャネルとフラグを使う</li>
<li>チャンネルにバッファがあるので注意。超えるとブロックする
<ul>
<li>きちんと読み込まないとデッドロック</li>
<li>書き込みのみ別のgoroutineに移すことで凌げる</li>
</ul></li>
</ul></li>
<li>Goのフォーマッティング → gofmt、golintを使うしかない</li>
<li>戻り値の型をinterfaceにしておくと、<code>nil</code>を返しても<code>nil</code>じゃないことがある
<ul>
<li>interfaceがnil判定されるには、具象型も<code>nil</code>である必要がある</li>
</ul></li>
<li><code>os.Exit()</code> と <code>log.Fatalf()</code> は一切 <code>defer</code> を呼ばないので注意
<ul>
<li>普通に <code>return</code> したほうが</li>
</ul></li>
<li>外部のブロックするようなコードの呼び出し
<ul>
<li>goroutineで包んで、自前でchannel化する</li>
</ul></li>
<li>まとめ: goを書くときは考え方を買える。「goに入りてはgoに従え」</li>
</ul>
<h1 id="tokuhiro-matsunoさんお待たせしましたperl-で-bdd-を簡単に実践する最高にクールなフレームワークができました">Tokuhiro Matsunoさん「お待たせしました。Perl で BDD を簡単に実践する最高にクールなフレームワークができました」</h1>
<ul>
<li>英題「Perl and testing libraries」</li>
<li>TDDでやってる人 → 一人</li>
<li>テスト書くのは嫌いだが、書く。でも怠けたい
<ul>
<li>少しのテストで最大限の効果</li>
</ul></li>
<li>歴史: <code>Test::More</code>, <code>Test::Class</code>
<ul>
<li><code>'dan' ne 'kogai'</code> どちらも <code>Test::Builder</code> に依存してて、基本的に同じ</li>
</ul></li>
<li>TAP : Test Anything Protocol
<ul>
<li><code>ok</code>と<code>not ok</code>を出して<code>prove</code>で</li>
<li><code>subtest</code>や<code>done_testing</code>のような拡張もできてる</li>
</ul></li>
<li><code>Test::Builder2</code>
<ul>
<li>2011年から初めてる</li>
<li>Perl6と同じくらい夢が詰まってる</li>
<li>Custom output, Full rewrite, OO-ish</li>
<li>まだ開発中。時間がかかる。すべてのモジュールに対して通るように</li>
</ul></li>
<li>Test::Pretty
<ul>
<li>出力をunicode文字を使った出力に変える</li>
<li>subtestの読みにくい出力を読みやすくする</li>
<li>モンキーパッチ当てまくってる</li>
</ul></li>
<li>Test::Ika
<ul>
<li>RSpecライク</li>
<li>Ikaとはikasamaさんのika</li>
<li>最終的に、ikasamaさんがメンテナンスすることに</li>
</ul></li>
<li>Test::Moreの開発が停滞している
<ul>
<li>Test::Builder2 は開発が中止となった</li>
</ul></li>
<li>Test::Kantan は Test::Builder に依存してない
<ul>
<li>出力をフックしたりしている</li>
<li>subtest にフックをかけられる – before_each、after_each。subtest以下すべてに適用</li>
<li>jasmineにインスパイアされてる</li>
<li>BDDっぽく書ける。given, when, then</li>
<li>Test::More のスタイルも使える</li>
<li>パワーアサート: B::Tree 使ってソースをhookして実現してる</li>
<li><code>'kogaidan' ne 'dankogai'</code></li>
<li>色がついてたほうが一般ウケする</li>
</ul></li>
<li><code>not ok 1..1</code> → テストの通ってる数はそんなに意味がない。all or nothing でよい
<ul>
<li>大規模ソフトウェアとかのインテグレーションとかなら意味があるかも知れないけど</li>
</ul></li>
<li>すぐに使いたいならTest::Prety、RSPEC厨ならTest::Ika or Test::Kantan
<ul>
<li>Test::Kantan はコントリビュータを募集中</li>
</ul></li>
</ul>
<h1 id="taiki-kawakamiさんperllint---yet-another-perl-source-code-linter">Taiki Kawakamiさん「Perl::Lint - Yet Another Perl Source Code Linter」</h1>
<p>こちらは、 <a href="http://gihyo.jp/news/report/01/yapcasia2014/0001">gihyo.jpさん</a> に掲載させて頂いてます。</p>
<h1 id="hakobeさんscala-in-perl-company-hatena">hakobeさん「Scala In Perl Company : Hatena」</h1>
<ul>
<li>Hatena はほぼすべてのプロダクトがPerl</li>
<li>なぜPerlか？
<ul>
<li>少ない記述量</li>
<li>実行手順（試行錯誤しやすい）</li>
<li>CPANライブラリ</li>
<li>WEBの開発基板</li>
<li>コミュニティ</li>
</ul></li>
<li>10年で起こったこと
<ul>
<li>スマホ、技術の高まり、ユーザの変化</li>
<li>ソフトウェア進化を継続することが必要</li>
</ul></li>
<li>Perlとソフトウェアの進化
<ul>
<li>単体テスト、CI、ソースコード解析、レビュー、段階的な変更、開発フロー見直し</li>
</ul></li>
<li>突然のランタイムエラー
<ul>
<li><code>$url-&gt;schema</code> で落ちたりとか、メソッド名の変更を追えてないブランチとか</li>
<li>エラー検知に限界がある</li>
<li>カバレッジをどこまで高めるのか</li>
</ul></li>
<li>安全なソフトウェアの変更が必要</li>
<li>mackerel → はてなのサーバ管理サービス
<ul>
<li>はてなIDは使わない。スケジュールの自由度がある</li>
<li>新言語投入のチャンス</li>
<li>静的型システム[MUST]、柔軟さ、Web開発、社内に開発者、ライブラリ</li>
</ul></li>
<li>Haskell の問題点 → 社内に人がいなかった</li>
<li>Scala
<ul>
<li>オブジェクト指向と関数型のハイブリッド</li>
<li>JVM。Javaと互換性</li>
</ul></li>
<li>Scalaな理由
<ul>
<li>多様な型がある。特に、代数的データ型を定義できる
<ul>
<li>Optional型 → undefチェックを矯正</li>
</ul></li>
<li>記述が柔軟。Perl Mongersも安心の書き心地
<ul>
<li>_とか型推論とか</li>
</ul></li>
<li>Javaのライブラリがそのまま使える。DBとかネットワークとか</li>
<li>社内に書ける人が居た</li>
</ul></li>
<li>環境
<ul>
<li>Emacs + sbt とか IntelliJ + sbt とか</li>
</ul></li>
<li>利点と欠点
<ul>
<li>コードの変更に強い</li>
<li>レビューが楽</li>
<li>コンパイルが長すぎる。3分かかる</li>
<li>学習コストが高い</li>
<li>Java界隈のことがわからない</li>
<li>型システムは最高</li>
</ul></li>
</ul>
<!--

# Kenichi Ishigakiさん「Get a kick out of CPAN」

こちらは、 [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) に掲載させて頂いてます。

-->



        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
