---
title: 今日は「第1回 「Haskellによる並列・並行プログラミング」読書会」の日です
---

[第1回 「Haskellによる並列・並行プログラミング」読書会](http://partake.in/events/b3f4f0f2-8c0a-47c9-b253-b6bd691a45f0)へ来ている。基本的に朗読形式なので、議論を中心にメモしておく。

* 訳者まえがき
    * 「放牧的」より「牧歌的」では
* まえがき
    * p.viii 「4、5、6、14章」の後に変な改行が入ってる
    * p.viii s/13章はまずII部/13章はまずI部/
* 1章 はじめに
* 1.1 用語：並列性と並行性
* 1.2 ツールとリソース
* 1.3 サンプルコード
    * p.4 プロンプトが一個だけ`%`になってる
* I部 並列Haskell
    * 「広範囲の並列ハードウェア」？ 「いろんな並列ハードウェア」？
    * GCとは→踏み込むと危険なのでスルー
    * p. 6 s/データフロー並列/4章 データフロー並列/
    * 不安定とは？ →性能が不安定という意味
* 2章 基本の並列性:Evalモナド
* 2.1 遅延評価と弱頭部正規形
    * p.10の|はなに？ → (box化された)Integerの意
    * :sprintのsは？ simplified
    * p.9 の例とかで `:: Int` がないと `x` が `_` になるんだけど？ → ghcの7.8系から
    * p.12 `z = _` になるんじゃないの？ → データコンストラクタは遅延されない
* 2.2 Evalモナド、rpar、rseq
    * `data Eval a` って右辺要らないの？ → 型定義のみ書いてるだけ
    * 「プログラムの残りは実行」とは？ → `f x`と`f y`も並列に走るという意味
    * p.18 s/`RTS -N2`/`+RTS -N2`/
* 2.3 例：並列数独ソルバ
    * p.21 s/2つのが出力/2つが出力/
* 2.4 Deepseq
    * `!` と `seq`の違いは？ → シンタクスシュガー
    * `NFData`って自動で`deriving`できないの？ → すべての型クラスは自動導出できるはず。`deepseq-generics`がある
    * `deepseq`は自分で実装することはないでしょう
    * 関数は正規形なのか → lambdaのbody部で簡約されているものがあるとまずい　
    * `deepseq`がO(n)って何？→評価は終わってるけど、データ構造は辿らないとダメなので
* 3章 評価戦略
    * `Strategy`は型だけでなく値も保つことに注意
    * 「1つの`Strategy`に梱包？」 → "we’ve packaged it up as a Strategy"
* 3.1 戦略の並列化
* 3.2 リストを並列に評価する戦略
* 3.3 例：K平均法
    * サンプル動かすなら、`cabal sandbox init` `cabal install --only-dependencies` `cabal build`がいい
* 3.3.1 K平均法の並列化　
* 3.3.2 性能と分析
    * 少なくとも `-Nn` の指定した `n` のOSスレッドは走ってる(実際にはもっと多い)
    * writeが並列だと影響しない？ → ハンドルに書くにはロックが必要なので影響する
    * `MVar`でとりあってるはず
    * ログを吐くようなスレッドを作ればよい → 本の終盤では`IORef`を使うことになる
* 3.3.3 スパーク活動の可視化
* 3.3.3 粒度
* 3.4 GCされるスパークと投機的並列性
    * `strat`を指しているものがあるかが重要
    * `rpar`を悪い使い方してくれてると警告してくれる？ → くれない
    * `using`を使えば確実？ → `using`対象は値だから、使われるはず
* 3.5 parBufferを使った遅延ストリームの並列化
* 3.6 チャンク分け戦略
* 3.7 同一性特性
    * スパークプールのサイズはオプションで変えられる (デフォルト:4096)
    * あふれると、並列にならない