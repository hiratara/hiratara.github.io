---
title: 今日はYAPC::Asia TOKYO 2015 Day 1 の日です
---

今日もビッグサイトの近くにおります。[gihyo.jpさんのレポート](http://gihyo.jp/news/report/01/yapcasia2015/0001)も更新されていますので、ぜひご覧くださいませ。

## オープニング

* @yapcasia 使ってね
* 5トラックあるよ
* タグは #yapcasia[A-E] でわけてね
* 同時通訳あるよ
* wifiのトラフィックレポートあるよ
* [ベストトーク投票](http://yapcasia.org/2015/vote/form)してね
* 6Fでランチあるよ（300食）。明日はランチセッションも別であるよ
* 懇親会18時からだよ
* スポンサーには感謝しましょう
* blogを書くまでがYAPC

## Larry Wallさん 「メリークリスマス！」

* Larryは今年61才
* 「2」にまつわる悪いことがあった
* 「6」でも「.pl」でもない話をする？
* トールキン　ホビット物語、指輪物語
    * 6本の映画。3*2本
    * 3+2 = 5 (!) Perl 5は決戦の行方
* Perl5は成功し、今でも成功を収めている
* Perl5はホビット物語、Perl6は指輪物語
* どちらも「15」年の労力
* N年かかったかどうかは、過去のことであれば関係ない
* 「2つのパーティー」「山を登る旅路の物語」
* 指輪物語はホビット物語から盗んだ点が多い
* Perlも成長の物語
* 様々な敵 - 「Wood Wide Web」
* Second System Syndrome を克服した Perl6
* Perl6はPerl5から色々盗んでいる
    * シジル
	* 簡単なことは簡単に
	* 実践的
* Perlが好かれているのは表面上ではなく真相の部分
* Perl6は表面の部分は代わっている
* Perl5には欠点がある
* Unixの正規表現やawkの型、Cの演算子
* Perl6では正規表現を再設計。Perl6のパーサをパターンで書ける
    * 他の言語はPerl5の正規表現を真似ているのは皮肉
* Perl6のいいところは？ → 経験しないとわからない
* どうやるかより何をやるか
* 型 - Mooseのようなもの。Meta Object Protocol
    * 今までの言語でここまで柔軟なものはない
* multi path parsingを整理
    * 正規表現 「//x がデフォルト」「パターンはstringではなくlanguage」
    * 1 path parsing 言語ごとに切り替える「Mixins」
* 単位元の扱い、大きな整数
* 言語を設計することは世界を設計すること
* 仲間。IRCには200人がログインしている
    * トロールもいるが仲良くしようとしている
    * 意見が違ってもいいけど仲良くしたい
* Perl5 スレッドとグローバル変数
    * BEGIN, CHECK, INIT, END : フェーザー
	* CHECK コンパイルの終わり、INIT ランタイムの始まり 
	* CATCH、CONTROL 例外処理
    * `signal(SIGINT).act: { ... }` プリミティブとして
	* マルチコアに対して対応
* `0, 1, *+* ... *` フィボナッチ
* `my ($a, $b, $c) = 42 xx *` lazy list
* contextの決定は実行時
* 実行時例外 : pythonよりクリーンな言語にできる
* 実行時の字句解析
* ANNOUNCEMENT!
    * christmas??
	* 2015!! の予定のつもりで頑張ってる
    * ボランティアなので。人生の方が大事だよね
* 機能を固めてる段階。今後は安定版のメンテも行う
* まずはrakudo。MoarVMも
* `-Ofun`
* Perl6のリライトの3分野
    * NFG : ユニコードのNFD, NFC
	* NSA : 科学用行列計算
	* GLR : セマンティックの単純化。リストのリストをできるよう
* 「正しく失敗する」
    * Perl6は失敗すると想定していた
	* Perl5は欠点があるが使われている。Perl5のよくない部分を直す
	* boot strapのPerl6コンパイラはまだ
* ユーザの邪魔をしない言語。自然言語のような言語
* 指輪物語から得たことは多い
* Perl7の設計できるまで長生きするかもね。
* パーティーを楽しみましょう！

## aerealさん、灘友さん「世界展開する大規模ウェブサービスのデプロイを支える技術」

* Miiverse
    * 世界展開。リージョン跨ぎ
    * Wii Uや3DSのアバターサービス
    * PC、スマホからも利用可能
    * 全てをWEBベースで実装
    * ゲームからAPIを叩くことも。専用ライブラリも
* インフラはHatena、クライアントはNintendo
    * ローカライズや運営は海外ごと
    * JS/US/EUの3リージョン構成
* Proxy server, AppServer, DB
    * DBはマルチマスタで相互レプリケーション
    * PC版はUSリージョンのみ
* Timeline, Empathy, Notificationを処理を分離。RESTで
* Capistrano2 + Git : いわゆるpull型
    * 海を越えると `git pull` は辛い
    * Gitサーバが耐えられなくなる
* Git slaveを用意する
    * lsyncdでinode監視してrsync
    * ファイル数多すぎてlsyncdの上限を超えた事件
    * rsync中のgit fetchで配布物がサーバ毎に変わる事件
* ロールでデプロイを分ける。ランダムスリープ
* デプロイ対象サーバの管理は Mackerel APIを使って
    * net-sshが負荷でセグフォするなど
    * サーバ毎にroleを分けてる
    * サブシステムはMackerelでAutoScale
* 内容による手動対応も多い

ここからバトンタッチ。

* 昔はRedmineで開発していた
* GitHub Enterpriseを導入
* コードレビュー用の `ghe` というリモートを別に用意している
    * 2箇所に `push` が必要
    * Merge pull requestボタンは使わない (GHE上でマージすると `HEAD` の不一致が起こる可能性)
* 複数のGitリポジトリの同期
    * `google/hesokuri` Clojureで書かれている
        * マッピングは静的に決まる
        * `ghe` のメンテなどに耐えられない
    * `ghm` はてな製
        * Webアプリ。同期したりしなかったり
	* 同期が直列 (リポジトリが増えるときつい)
	* 古いリビジョンのデプロイ
* 新たなgit同期システムを開発
    * JSONのREST API群
    * Gitサーバ登録・取得、マスタ昇格・降格、リポジトリ、ジョブ実施
    * GHEへpush → リポジトリsyncへWEB HOOK → `pull@して`push`
    * HTTP POSTすればいいだけなのでいろいろなサービスとの連携が容易
    * 複数スレーブを扱える、同期ジョブの並列実行

ここでまたバトンタッチ。

* pull型の問題
    * 全部 `commit` する場合 : リポジトリが肥大化（コンパイルしたものも）
    * ソースだけの場合 : デプロイが長い、違う成果物
* Consulとstretcher
    * 配布物をAmazon S3などへ保存
    * デプロイのmanifest(YAML)も
    * consul event でイベント通知
    * イベントを受けてデプロイを実施
    * consulなので並列
    * S3なので負荷は考えなくていい
    * gitリポジトリに成果物は不要
    * 追加、rollbackなどもmanifest指定だけ
* 成果物はjenkins先生におまかせ
* 100台へのデプロイでベンチ
    * 1,142秒から29秒
    * `git pull` がそんなに早くない、という話
* AutoScaleとの連携をしたい (ただし、初回はconsulイベントは送れない)
* Miiverse での利用もしたい (3リージョン必要)
* デプロイの高速化で、価値のお届けも高速化
* Q. どの言語で？ なぜ？
    * A. Perl5。MiiverseなどはPerl5で実装されている。開発を支えるものなので冒険せずに済むもの
* Q. デプロイの頻度は？
    * A. 2週間に一度。bug fixがあればいつでも
* Q. capistranoでデプロイに失敗した時の検出は
    * A. strecherは成功・失敗のコマンドフックがある。Ikachan経由で通知を
* Q. Merge pull request ボタンは使えるようになった？
    * A. リポジトリ同期システムがあれば使えるようになった
* Q. コードデプロイの検討は？
    * A. 検討してない。確かまだリリースされていなかった
* Q. consulは台数が少ないとメリットない？
    * A. 30～50台くらいでgitサーバの負荷が高くなる

## Kazuho Okuさん 「HTTP/2 時代のウェブサイト設計」

* サーバの応答遅延とクリック率の研究 by Microsoft
    * 2秒の遅延で4.4%クリック率が下がる
* WEBサイトあたりのデータ転送量の増加
* インタネットのバンド幅の増加、年率50%
* ページロード時間はバンド幅に比例しない。1.6Mbps程度で頭打ち
* バンド幅ではなくレイテンシーが小さいとページロードが速い
* 1RTTにに1リクエストしか送れない
    * HTTP/1.1 のパイプラインによる改善
        * サーバにおくれたかわからない、最初の転送が遅いと詰まる、サーバ実装にバグ
* レイテンシは光の速度で決まる。アメリカで80ms
* 携帯回線のレイテンシのおおきさ
* レイテンシに負けないプロトコルの作成 HTTP/2
* ChromeのQUICプロトコルを標準化
    * バイナリ、多重化、ヘッダ圧縮、優先度制御、サーバプッシュ
* バイナリ
    * 脆弱性の防止
        * asciiだと、スペースなどの解釈があいまいとなる
    * 転送データを小さくする
    * ヘッダ圧縮がバイナリなんだから
* 全ての通信データはフレームに
    * 様々なフレームタイプがある
* 先にHEADERSフレームをクライアントとサーバで交換、その後DATAフレーム
* METHODやschmeもヘッダに入れることに注意
* `h2i` ASCIIでHTTP/2を試せるツール
* 同時に100以上のリクエストが可能、レスポンスも任意、stream IDで制御
* HTTP/1.1のヘッダのおおきさ → 100レスポンスでで30KBとか
    * HPACK : 静的は不満圧縮、再登場の文字列をオフセットで、など
    * 最初のリクエストは半分くらいのサイズに
	* 2回目は直前のリクエストを利用して 1/5 に
	* 3回目は1/20程度に！
	* 画像、CSSの大量な数の転送に強い
* 小さい画像をたくさん並べるでもデモ
    * リロードを続けて失敗が(まあこういうことも)
* 優先度
    * クライアントが指定
	* サーバが尊重
* HTTP/1.1, SPDY/3.1, HTTP/2 の比較
* Firefoxの優先度制御
    * weightに比例して優先してレスポンスを返す
    * HEADのJSとBODYのJSで違う
* chromeの優先度制御 : 残念
    * 依存関係を分析してない
	* 画像がバンド幅を食いつぶす
* H2Oの優先度制御
    * クライアントの優先度が怪しいとき、サーバ側が優先度制御する
* 他のサーバの優先度制御
    * nghttp2 は頑張ってるけど、他はやばい
	* サーバがやらないとクライアントの最適化が効かない
* サーバプッシュ
    * ラウンドトリップを0にする
	* `<link />` を見るとかして、予測して返す
	* RFC通りだと速くならない
* キャッシュに入っている場合はpushしたくない
    * H2O 1.5 : cache-aware server-push → Cookieでキャッシュに何を持ってるか追跡する
* HTTP/2 で無意味になるクライアントの最適化
    * アセットの結合 : 余分なものが入っていると転送量が増えるため
	* expiresの利用 : 304レスポンスを使い放題なので。 `?` の管理が面倒
    * ドメインシャーディング : 複数TCPにしてしまうと、優先度制御ができない
        * WEBアプリからのレスポンスもCDNを通すといい
* 「H2Oを使えば売り上げが上がる」
* HTTP/2はHTTPS限定
    * 無料で。 LetsEncrypt 11/16から
    * Ciphersuites : 使ってよい暗号化手法の一覧
    * Forward Secrecy : 暗号カギを変える
        * CiphersuitesのみではPFSにならない
        * セッションキャッシュによって
        * session resumption
        * session ticket : クッキーと同様、サーバが覚える
            * キーを暗号化する鍵がバレルと終わる
            * session ticketを無効にする
        * H2Oはクラスタ化してもmemcachedでresumption可。session ticketの秘密鍵も自動更新
* nginxの技術者とも意見交換したので追いかけてくる
    * H2Oはその先を行くので、ぜひ使ってください
* Q. RFCの機能への対応表一覧は？
    * A. `MUST`、`SHOULD`は大体対応している
* Q. 画像が表示できなかった理由のイメージは？
    * A. サーバ負荷の問題ではないかと予想
* Q. HTTPはRPCでも使われていてHTTP/2の恩恵は受けられるが、クライアント側の状況は？
    * A. 今のところ `libcurl` のみ。
* Q. 1st paint timeはどうやって計測している？ Firefoxは対応してなかったはず
    * A. 最後のCSS、JSの転送終了を見ている。いつ1st paintが起きうるか、で測定
* Q. 普及時期は？
    * A. Firefox, Chromeは対応済。主要なブラウザもサーバも秋には対応される。HTTPSである必要があるのでLetsEncrypt待ち。早いと今年の年末には3～4割になるのでは
* Q. チューニングの勘所はApacheなどと違う？
    * A. デフォルトで最適になるようにするので、チューニングは不要。サイト設計のファイルサイズが変わるのが
