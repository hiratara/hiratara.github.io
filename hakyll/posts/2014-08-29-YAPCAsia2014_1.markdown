---
title: 今日は YAPC::Asia Tokyo 2014 の１日目です
---

今日からが[本番](http://yapcasia.org/)です。これから会場に入ります。

本日も一部の内容は [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) にも掲載していますので、併せてご覧ください。


# オープニング / yusukebeさん

- みなさんが作る会です
- JPAの"和田"さんです
- "There is MORE THAN ONE WAY to enjoy it!"
- 無限コーヒーあるよ！ かき氷もレッドブルも
    - スピーカーと話して欲しい
    - 仕掛けは用意したので、みなさんで交流してください
- イベントホール以外飲食禁止
- ポータブルWifiの電源はOFFに！
- 同時翻訳あり。機械は無くさないように
- ベストトークの投票してね
- ハッシュタグは [#yapcasia](https://twitter.com/search?q=%23yapcasia) 。ブログもね！


# Satoshi Suzukiさん「インフラエンジニア(狭義)は死んだ 」

こちらは、 [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) に掲載させて頂いてます。


# Daisuke Makiさん「Go For Perl Mongers」

- みんなで発声練習してください「YAPC大好き！」
- Go を初めて1年弱。10万行くらい書いた
    - 最初の4万行でgoの落とし穴にかなりハマった
- 質問は話の途中か廊下、Twitterなどで
- Go は LLっぽいCである
    - LLののりを引きずるとGoが嫌いになる
    - 設計、考え方など、全く違うメンタリティで
- 例外
    - Goに例外はない
    - panic()とrecover()は本当にどうにもならない時のみ
- オブジェクト(継承)なんてない
    - オーバーライドしたメソッド呼び出しに見えるけど、違う
- GoroutineはPOSIXスレッドではない
    - killもwaitpidもできない
    - Goroutineは何百万個作ってもよい
    - 非同期処理に精通していると、同期処理は書きやすい
- 例外とエラーについて
    - panic()になったら、ランタイムがどういう状態にあるのか保証できない(メモリエラーなど)
    - 早めにエラー処理(return)し、必ず呼び元で確認する
    - 複数の戻り値でerrorを返す。 `return i, nil`
    - `if err != nil {` を見たらエラー処理だと思えるようになる。流儀に沿ったほうがいい
    - `panic`は本当に復帰できない場合のみ
    - `recover`は本当に大丈夫だとわかってる`panic`に対してのみ
    - `fmt.Errorf()` エラーメッセージは小文字で始めないと怒られる
    - `fmt` 「フント」と読まないとgoの人に怒られる
- Goでの構造体設計
    - Cの構造体チック
    - オブジェクトはない。レシーバとメソッドはある。継承はない
    - 親からフィールドやメソッドをもらうことができない
    - 呼び出したいオブジェクトを埋め込んで、呼び出す
    - 無名埋め込みができる。あたかも継承したように見える
        - が、移譲。レシーバが子クラスにならない
        - `child.printReceiver ` と `child.Base.printReceiver` は匿名にしても同じ意味
    - インタフェース中心にする。小さい部品を作ってmix-inすることで再利用
    - インタフェースを定義し、埋め込みでそれを満たす(MooseのRole)
    - Genericsはあきらめましょう。公式な答え「考えてもいい」
    - APIを考える→「草食動物」ではなく「草を食べる、ことができるもの」
    - go-stf-server はその苦闘の歴史なので、興味があれば
- 並列の道具揃ってる
    - goroutineはスレッド、channelはスレッド間通信
    - どのスレッドでいつ実行されるか不明
    - 回収する必要はないが、同期しないとリソースの開放に問題
    - goroutineの停止、終了を待ったりなど、一切の制御は不能
    - channelを使って同機を獲る `defer` の中でチャネルに送ると、終了を検知できる
    - `defer` はgoroutineの終了を待たないと終わらない
    - goroutineを停止させるには、チャネルとフラグを使う
    - チャンネルにバッファがあるので注意。超えるとブロックする
        - きちんと読み込まないとデッドロック
        - 書き込みのみ別のgoroutineに移すことで凌げる
- Goのフォーマッティング → gofmt、golintを使うしかない
- 戻り値の型をinterfaceにしておくと、`nil`を返しても`nil`じゃないことがある
    - interfaceがnil判定されるには、具象型も`nil`である必要がある
- `os.Exit()` と `log.Fatalf()` は一切 `defer` を呼ばないので注意
    - 普通に `return` したほうが
- 外部のブロックするようなコードの呼び出し
    - goroutineで包んで、自前でchannel化する
- まとめ: goを書くときは考え方を買える。「goに入りてはgoに従え」


# Tokuhiro Matsunoさん「お待たせしました。Perl で BDD を簡単に実践する最高にクールなフレームワークができました」

- 英題「Perl and testing libraries」
- TDDでやってる人 → 一人
- テスト書くのは嫌いだが、書く。でも怠けたい
-- 少しのテストで最大限の効果
- 歴史: `Test::More`, `Test::Class`



<!--

# Taiki Kawakamiさん「Perl::Lint - Yet Another Perl Source Code Linter」

こちらは、 [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) に掲載させて頂いてます。


# Kenichi Ishigakiさん「Get a kick out of CPAN」

こちらは、 [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) に掲載させて頂いてます。

-->
