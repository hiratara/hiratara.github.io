---
title: 今日は YAPC::Asia Tokyo 2014 の１日目です
---

今日からが[本番](http://yapcasia.org/)です。これから会場に入ります。

本日も一部の内容は [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) にも掲載していますので、併せてご覧ください。


# オープニング / yusukebeさん

- みなさんが作る会です
- JPAの"和田"さんです
- "There is MORE THAN ONE WAY to enjoy it!"
- 無限コーヒーあるよ！ かき氷もレッドブルも
    - スピーカーと話して欲しい
    - 仕掛けは用意したので、みなさんで交流してください
- イベントホール以外飲食禁止
- ポータブルWifiの電源はOFFに！
- 同時翻訳あり。機械は無くさないように
- ベストトークの投票してね
- ハッシュタグは [#yapcasia](https://twitter.com/search?q=%23yapcasia) 。ブログもね！


# Satoshi Suzukiさん「インフラエンジニア(狭義)は死んだ 」

こちらは、 [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) に掲載させて頂いてます。


# Daisuke Makiさん「Go For Perl Mongers」

- みんなで発声練習してください「YAPC大好き！」
- Go を初めて1年弱。10万行くらい書いた
    - 最初の4万行でgoの落とし穴にかなりハマった
- 質問は話の途中か廊下、Twitterなどで
- Go は LLっぽいCである
    - LLののりを引きずるとGoが嫌いになる
    - 設計、考え方など、全く違うメンタリティで
- 例外
    - Goに例外はない
    - panic()とrecover()は本当にどうにもならない時のみ
- オブジェクト(継承)なんてない
    - オーバーライドしたメソッド呼び出しに見えるけど、違う
- GoroutineはPOSIXスレッドではない
    - killもwaitpidもできない
    - Goroutineは何百万個作ってもよい
    - 非同期処理に精通していると、同期処理は書きやすい
- 例外とエラーについて
    - panic()になったら、ランタイムがどういう状態にあるのか保証できない(メモリエラーなど)
    - 早めにエラー処理(return)し、必ず呼び元で確認する
    - 複数の戻り値でerrorを返す。 `return i, nil`
    - `if err != nil {` を見たらエラー処理だと思えるようになる。流儀に沿ったほうがいい
    - `panic`は本当に復帰できない場合のみ
    - `recover`は本当に大丈夫だとわかってる`panic`に対してのみ
    - `fmt.Errorf()` エラーメッセージは小文字で始めないと怒られる
    - `fmt` 「フント」と読まないとgoの人に怒られる
- Goでの構造体設計
    - Cの構造体チック
    - オブジェクトはない。レシーバとメソッドはある。継承はない
    - 親からフィールドやメソッドをもらうことができない
    - 呼び出したいオブジェクトを埋め込んで、呼び出す
    - 無名埋め込みができる。あたかも継承したように見える
        - が、移譲。レシーバが子クラスにならない
        - `child.printReceiver ` と `child.Base.printReceiver` は匿名にしても同じ意味
    - インタフェース中心にする。小さい部品を作ってmix-inすることで再利用
    - インタフェースを定義し、埋め込みでそれを満たす(MooseのRole)
    - Genericsはあきらめましょう。公式な答え「考えてもいい」
    - APIを考える→「草食動物」ではなく「草を食べる、ことができるもの」
    - go-stf-server はその苦闘の歴史なので、興味があれば
- 並列の道具揃ってる
    - goroutineはスレッド、channelはスレッド間通信
    - どのスレッドでいつ実行されるか不明
    - 回収する必要はないが、同期しないとリソースの開放に問題
    - goroutineの停止、終了を待ったりなど、一切の制御は不能
    - channelを使って同機を獲る `defer` の中でチャネルに送ると、終了を検知できる
    - `defer` はgoroutineの終了を待たないと終わらない
    - goroutineを停止させるには、チャネルとフラグを使う
    - チャンネルにバッファがあるので注意。超えるとブロックする
        - きちんと読み込まないとデッドロック
        - 書き込みのみ別のgoroutineに移すことで凌げる
- Goのフォーマッティング → gofmt、golintを使うしかない
- 戻り値の型をinterfaceにしておくと、`nil`を返しても`nil`じゃないことがある
    - interfaceがnil判定されるには、具象型も`nil`である必要がある
- `os.Exit()` と `log.Fatalf()` は一切 `defer` を呼ばないので注意
    - 普通に `return` したほうが
- 外部のブロックするようなコードの呼び出し
    - goroutineで包んで、自前でchannel化する
- まとめ: goを書くときは考え方を買える。「goに入りてはgoに従え」


# Tokuhiro Matsunoさん「お待たせしました。Perl で BDD を簡単に実践する最高にクールなフレームワークができました」

- 英題「Perl and testing libraries」
- TDDでやってる人 → 一人
- テスト書くのは嫌いだが、書く。でも怠けたい
    - 少しのテストで最大限の効果
- 歴史: `Test::More`, `Test::Class`
    - `'dan' ne 'kogai'` どちらも `Test::Builder` に依存してて、基本的に同じ
- TAP : Test Anything Protocol
    - `ok`と`not ok`を出して`prove`で
    - `subtest`や`done_testing`のような拡張もできてる
- `Test::Builder2`
    - 2011年から初めてる
    - Perl6と同じくらい夢が詰まってる
    - Custom output, Full rewrite, OO-ish
    - まだ開発中。時間がかかる。すべてのモジュールに対して通るように
- Test::Pretty
    - 出力をunicode文字を使った出力に変える
    - subtestの読みにくい出力を読みやすくする
    - モンキーパッチ当てまくってる
- Test::Ika
    - RSpecライク
    - Ikaとはikasamaさんのika
    - 最終的に、ikasamaさんがメンテナンスすることに
- Test::Moreの開発が停滞している
    - Test::Builder2 は開発が中止となった
- Test::Kantan は Test::Builder に依存してない
    - 出力をフックしたりしている
    - subtest にフックをかけられる
    -- before_each、after_each。subtest以下すべてに適用
    - jasmineにインスパイアされてる
    - BDDっぽく書ける。given, when, then
    - Test::More のスタイルも使える
    - パワーアサート: B::Tree 使ってソースをhookして実現してる
    - `'kogaidan' ne 'dankogai'` 
    - 色がついてたほうが一般ウケする
- `not ok 1..1` → テストの通ってる数はそんなに意味がない。all or nothing でよい
    - 大規模ソフトウェアとかのインテグレーションとかなら意味があるかも知れないけど
- すぐに使いたいならTest::Prety、RSPEC厨ならTest::Ika or Test::Kantan
    - Test::Kantan はコントリビュータを募集中


# Taiki Kawakamiさん「Perl::Lint - Yet Another Perl Source Code Linter」

こちらは、 [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) に掲載させて頂いてます。


# hakobeさん「Scala In Perl Company : Hatena」

- Hatena はほぼすべてのプロダクトがPerl
- なぜPerlか？
-- 少ない記述量
-- 実行手順（試行錯誤しやすい）
-- CPANライブラリ
-- WEBの開発基板
-- コミュニティ
- 10年で起こったこと
-- スマホ、技術の高まり、ユーザの変化
-- ソフトウェア進化を継続することが必要
- Perlとソフトウェアの進化
-- 単体テスト、CI、ソースコード解析、レビュー、段階的な変更、開発フロー見直し
- 突然のランタイムエラー
-- `$url->schema` で落ちたりとか、メソッド名の変更を追えてないブランチとか
-- エラー検知に限界がある
-- カバレッジをどこまで高めるのか
- 安全なソフトウェアの変更が必要
- mackerel → はてなのサーバ管理サービス
-- はてなIDは使わない。スケジュールの自由度がある
-- 新言語投入のチャンス
-- 静的型システム[MUST]、柔軟さ、Web開発、社内に開発者、ライブラリ
- Haskell の問題点 → 社内に人がいなかった
- Scala
-- オブジェクト指向と関数型のハイブリッド
-- JVM。Javaと互換性
- Scalaな理由
-- 多様な型がある。特に、代数的データ型を定義できる
--- Optional型 → undefチェックを矯正
-- 記述が柔軟。Perl Mongersも安心の書き心地
--- _とか型推論とか
-- Javaのライブラリがそのまま使える。DBとかネットワークとか
-- 社内に書ける人が居た
- 環境
-- Emacs + sbt とか IntelliJ + sbt とか 
- 利点と欠点
-- コードの変更に強い
-- レビューが楽
-- コンパイルが長すぎる。3分かかる
-- 学習コストが高い
-- Java界隈のことがわからない
-- 型システムは最高


<!--

# Kenichi Ishigakiさん「Get a kick out of CPAN」

こちらは、 [gihyo.jpさん](http://gihyo.jp/news/report/01/yapcasia2014/0001) に掲載させて頂いてます。

-->
