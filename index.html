<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Born in Tomakomai city - Top</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <!-- Google Analytics tracking codes -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-7637699-4', 'hiratara.github.io');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <!-- facebook SDK -->
        <div id="fb-root"></div>
        <script>(function(d, s, id) {
          var js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s); js.id = id;
          js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=100848266724416";
          fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script>

        <div id="header">
            <div id="logo">
                <a href="./">Born in Tomakomai city</a>
            </div>
            <div id="navigation">
                <a href="./">Top</a>
                <a href="./about.html">About</a>
                <a href="./contact.html">Contact</a>
                <a href="./archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            

<div>
  <h1><a href="./posts/2014-10-05-fairly_tmvar.html">Haskellによる並列・並行プログラミングの10.9</a></h1>

<div class="info">
    Posted on October  5, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-10-05-fairly_tmvar.html" data-text="Haskellによる並列・並行プログラミングの10.9" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-10-05-fairly_tmvar.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<p>公平性のある <code>TMVar</code> を実施しなさいというお題の<a href="https://github.com/hiratara/parconc-examples/commit/43f0be6ea3d39f6b277cb599f46cae1539ed0681">回答</a>を書いたので簡単に解説。</p>
<p>例えば <code>putMVar</code> ですでに値が入っているとき、キューに <code>TVar</code> を突っ込んでおいてそのままブロックし、 <code>takeMVar</code> によって値が空になったら起こして欲しい。が、書籍にも書いてあるとおり、 <code>STM</code> モナドではブロックは <code>retry</code> なので、ブロックするとキューに <code>TVar</code> を突っ込んだってこともトランザクションの破棄によって捨てられてしまう。</p>
<p>そこで、<code>STM</code>モナドではキューに突っ込むところまでやり、ブロックする処理は戻り値の <code>IO</code> アクションに任せることにするとうまくいく。以下の部分だ。</p>
<pre><code>putTMVar :: Show a =&gt; TMVar a -&gt; a -&gt; STM.STM (IO ())
...(snip)...
    Just _  -&gt; do
      t' &lt;- STM.newTVar (Just a)
      STM.writeTVar queue (qs ++ [t'])
      return $ do
        STM.atomically $ do
          tvar &lt;- STM.readTVar t'
          case tvar of
           Nothing -&gt; return ()
           Just _ -&gt; STM.retry
        return ()</code></pre>
<p><code>t'</code>をキューに突っ込んだ後は、ブロックするための <code>IO</code> モナドを作っている。この <code>IO</code> 値内で <code>atomically</code> + <code>retry</code> させることでブロックを実現している。</p>
<p>型が変わったせいで、利用側も若干めんどくさくなるが、原則 <code>join</code> で <code>atomically</code> の戻り値を潰すだけで問題ない。</p>
<pre><code>    join . STM.atomically $ putTMVar done 1</code></pre>
<pre><code>  n1 &lt;- join . STM.atomically $ takeTMVar done</code></pre>

</div>



<div>
  <h1><a href="./posts/2014-09-23-let_ghci_load_compiled_codes.html">cabal buildで作った*.oをcabal replで再利用させる</a></h1>

<div class="info">
    Posted on September 23, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-09-23-let_ghci_load_compiled_codes.html" data-text="cabal buildで作った*.oをcabal replで再利用させる" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-09-23-let_ghci_load_compiled_codes.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<p>最初に断っておくと、開発時にこの方法を使うことは稀だと思う(<a href="https://twitter.com/search?q=%23heyhey_haskell">#heyhey_haskell</a>懇親会調べ)。あくまでも興味本位でやっていることだとを念頭に入れておいてもらいたい。</p>
<p><a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/ghci-compiled.html">ghciのマニュアル</a>に書いてある原理は把握した上で、やりたかったのは<a href="http://stackoverflow.com/questions/15125825/how-to-reuse-cabal-compiled-modules-when-using-ghci">stackoverflowに出ていたこの質問</a>。幸い <code>cabal repl</code>だと、 <code>-odir</code> に適切な値を渡してくれるので、自前でこの質問にあるようなオプションを指定する必要はない。</p>
<p>が、ghc 7.8.3現在では、これだけではうまくいかない。まず、 <code>*.cabal</code> 内に <code>executable</code> として指定されているターゲットについては <a href="http://d.hatena.ne.jp/kazu-yamamoto/20130912/1378955823">kazu-yamamotoさんのエントリ</a> に書いてあるとおり <code>cabal</code> は静的ライブラリしか作らず <code>ghci</code> は動的ライブラリを見に行くのでうまく行かない。これは以下のようにbuildしておくと<code>ghci</code>から<code>*.o</code>を参照するようになる。</p>
<pre><code>cabal build --ghc-option=-dynamic sudoku3</code></pre>
<p>もっとひどいのは <code>library</code> 指定されている方で、 <code>cabal</code> のissueに上げられている <a href="https://github.com/haskell/cabal/issues/2048">この問題</a> が ghc-7.8.3 でも解決していない。これに対するワークアラウンドは以下のようなもの。</p>
<pre><code>cabal repl --ghc-options='-dynamic -osuf dyn_o -hisuf dyn_hi' lib:typedperl</code></pre>
<p>どうしてこれで <code>cabal</code> が差し込んでいる <code>-dynamic-too</code> が悪さしなくなるのか理解しがたい部分もあるが、こちらの環境ではこれで望みどおりの挙動(コンパイル済コードについてはコンパイルが走らない)となった。いずれにせよ、<a href="https://ghc.haskell.org/trac/ghc/ticket/8736">ghc 7.8.4では直して欲しい問題</a>である。</p>

</div>



<div>
  <h1><a href="./posts/2014-09-21-conc_haskell_1.html">今日は「第1回 「Haskellによる並列・並行プログラミング」読書会」の日です</a></h1>

<div class="info">
    Posted on September 21, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-09-21-conc_haskell_1.html" data-text="今日は「第1回 「Haskellによる並列・並行プログラミング」読書会」の日です" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-09-21-conc_haskell_1.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<p><a href="http://partake.in/events/b3f4f0f2-8c0a-47c9-b253-b6bd691a45f0">第1回 「Haskellによる並列・並行プログラミング」読書会</a>へ来ている。基本的に朗読形式なので、議論を中心にメモしておく。</p>
<ul>
<li>訳者まえがき
<ul>
<li>「放牧的」より「牧歌的」では</li>
</ul></li>
<li>まえがき
<ul>
<li>p.viii 「4、5、6、14章」の後に変な改行が入ってる</li>
<li>p.viii s/13章はまずII部/13章はまずI部/</li>
</ul></li>
<li>1章 はじめに</li>
<li>1.1 用語：並列性と並行性</li>
<li>1.2 ツールとリソース</li>
<li>1.3 サンプルコード
<ul>
<li>p.4 プロンプトが一個だけ<code>%</code>になってる</li>
</ul></li>
<li>I部 並列Haskell
<ul>
<li>「広範囲の並列ハードウェア」？ 「いろんな並列ハードウェア」？</li>
<li>GCとは→踏み込むと危険なのでスルー</li>
<li>p. 6 s/データフロー並列/4章 データフロー並列/</li>
<li>不安定とは？ →性能が不安定という意味</li>
</ul></li>
<li>2章 基本の並列性:Evalモナド</li>
<li>2.1 遅延評価と弱頭部正規形
<ul>
<li>p.10の|はなに？ → (box化された)Integerの意</li>
<li>:sprintのsは？ simplified</li>
<li>p.9 の例とかで <code>:: Int</code> がないと <code>x</code> が <code>_</code> になるんだけど？ → ghcの7.8系から</li>
<li>p.12 <code>z = _</code> になるんじゃないの？ → データコンストラクタは遅延されない</li>
</ul></li>
<li>2.2 Evalモナド、rpar、rseq
<ul>
<li><code>data Eval a</code> って右辺要らないの？ → 型定義のみ書いてるだけ</li>
<li>「プログラムの残りは実行」とは？ → <code>f x</code>と<code>f y</code>も並列に走るという意味</li>
<li>p.18 s/<code>RTS -N2</code>/<code>+RTS -N2</code>/</li>
</ul></li>
<li>2.3 例：並列数独ソルバ
<ul>
<li>p.21 s/2つのが出力/2つが出力/</li>
</ul></li>
<li>2.4 Deepseq
<ul>
<li><code>!</code> と <code>seq</code>の違いは？ → シンタクスシュガー</li>
<li><code>NFData</code>って自動で<code>deriving</code>できないの？ → すべての型クラスは自動導出できるはず。<code>deepseq-generics</code>がある</li>
<li><code>deepseq</code>は自分で実装することはないでしょう</li>
<li>関数は正規形なのか → lambdaのbody部で簡約されているものがあるとまずい　</li>
<li><code>deepseq</code>がO(n)って何？→評価は終わってるけど、データ構造は辿らないとダメなので</li>
</ul></li>
<li>3章 評価戦略
<ul>
<li><code>Strategy</code>は型だけでなく値も保つことに注意</li>
<li>「1つの<code>Strategy</code>に梱包？」 → “we’ve packaged it up as a Strategy”</li>
</ul></li>
<li>3.1 戦略の並列化</li>
<li>3.2 リストを並列に評価する戦略</li>
<li>3.3 例：K平均法
<ul>
<li>サンプル動かすなら、<code>cabal sandbox init</code> <code>cabal install --only-dependencies</code> <code>cabal build</code>がいい</li>
</ul></li>
<li>3.3.1 K平均法の並列化　</li>
<li>3.3.2 性能と分析
<ul>
<li>少なくとも <code>-Nn</code> の指定した <code>n</code> のOSスレッドは走ってる(実際にはもっと多い)</li>
<li>writeが並列だと影響しない？ → ハンドルに書くにはロックが必要なので影響する</li>
<li><code>MVar</code>でとりあってるはず</li>
<li>ログを吐くようなスレッドを作ればよい → 本の終盤では<code>IORef</code>を使うことになる</li>
</ul></li>
<li>3.3.3 スパーク活動の可視化</li>
<li>3.3.3 粒度</li>
<li>3.4 GCされるスパークと投機的並列性
<ul>
<li><code>strat</code>を指しているものがあるかが重要</li>
<li><code>rpar</code>を悪い使い方してくれてると警告してくれる？ → くれない</li>
<li><code>using</code>を使えば確実？ → <code>using</code>対象は値だから、使われるはず</li>
</ul></li>
<li>3.5 parBufferを使った遅延ストリームの並列化</li>
<li>3.6 チャンク分け戦略</li>
<li>3.7 同一性特性
<ul>
<li>スパークプールのサイズはオプションで変えられる (デフォルト:4096)</li>
<li>あふれると、並列にならない</li>
</ul></li>
</ul>

</div>



<div>
  <h1><a href="./posts/2014-09-14-parallel-haskel-excersize.html">Haskellによる並列・並行プログラミングの4.2.1</a></h1>

<div class="info">
    Posted on September 14, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-09-14-parallel-haskel-excersize.html" data-text="Haskellによる並列・並行プログラミングの4.2.1" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-09-14-parallel-haskel-excersize.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<blockquote>
<p><a href="http://www.amazon.co.jp/Haskell%E3%81%AB%E3%82%88%E3%82%8B%E4%B8%A6%E5%88%97%E3%83%BB%E4%B8%A6%E8%A1%8C%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Simon-Marlow/dp/4873116899%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Ddays0aa-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873116899" target="_top">Haskellによる並列・並行プログラミング</a><br />Simon Marlow 山下 伸夫 <br /><a href="http://www.amazon.co.jp/Haskell%E3%81%AB%E3%82%88%E3%82%8B%E4%B8%A6%E5%88%97%E3%83%BB%E4%B8%A6%E8%A1%8C%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-Simon-Marlow/dp/4873116899%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Ddays0aa-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4873116899" target="_top"><img src="http://ecx.images-amazon.com/images/I/51R0ZMN-OJL._SL75_.jpg" border="0" alt="4873116899" /></a><br /><img src="http://www.assoc-amazon.jp/e/ir?t=days0aa-22&l=ur2&o=9" width="1" height="1" style="border: none;" alt /></p>
</blockquote>
<p>こちらの演習問題の解答が <a href="http://stackoverflow.com/questions/24773130/parallel-haskell-rate-limiting-the-producer">stackoverflow</a> とか <a href="https://github.com/erantapaa/parconc-examples/commit/d2c657c516377c29bca2521452dbfbe966ef6ee4">github</a> に上がってるんだけど、間違えてそうなので<a href="https://github.com/hiratara/parconc-examples/commit/639abe2cad1fc3529313981ede51d5364126c115">自分が書いたもの</a>を解説しておく。</p>
<p>問題の例を読むと、一回のforkで生産する要素数は200だけど、消費者側が100個目を消費したところで次のforkが走り始める必要があることがわかる。これがなかなか難しい。</p>
<p>まず簡単なところから。型は問題文で与えられているので、<code>streamFold</code>は自明である。<code>Fork</code>は<code>Cons</code>を持っているので、<code>fork</code>する以外は<code>Cons</code>と同じ事をやるだけでいい。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">streamFold ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> b <span class="ot">-&gt;</span> <span class="dt">Par</span> a
streamFold fn <span class="fu">!</span>acc instrm <span class="fu">=</span> <span class="kw">do</span>
  ilst <span class="ot">&lt;-</span> get instrm
  <span class="kw">case</span> ilst <span class="kw">of</span>
    <span class="dt">Nil</span>      <span class="ot">-&gt;</span> return acc
    <span class="dt">Cons</span> h t <span class="ot">-&gt;</span> streamFold fn (fn acc h) t
    <span class="dt">Fork</span> kick (<span class="dt">Cons</span> h t) <span class="ot">-&gt;</span> fork kick <span class="fu">&gt;&gt;</span> streamFold fn (fn acc h) t</code></pre>
<p><code>streamFromList</code>は問題文よりchunkの大きさとforkするタイミングを渡せって言われてるので以下の型。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ForkSetting</span> <span class="fu">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
<span class="ot">streamFromList ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Par</span> (<span class="dt">Stream</span> a)
<span class="ot">streamFromList' ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">ForkSetting</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Par</span> (<span class="dt">Stream</span> a)</code></pre>
<p>これにあわせて<code>loop</code>も型を変える必要がある。が、さらにもうひと工夫 <code>Maybe (IVar (IList a))</code> という引数が必要で、これは後述する。　</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loop ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">IVar</span> (<span class="dt">IList</span> a) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">IVar</span> (<span class="dt">IList</span> a)) <span class="ot">-&gt;</span> <span class="dt">Par</span> ()</code></pre>
<p><code>loop</code> の通常時の動作は改修前と変わらない。<code>loop</code>の引数の変更にあわせてパラメータを適切に受け渡すだけである。ただし、追加したカウンタのデクリメントは必要である。　</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  loop _ [] var _ <span class="fu">=</span> put var <span class="dt">Nil</span>   <span class="co">-- &lt;4&gt;</span>
  loop (n, k) (x<span class="fu">:</span>xs) var nVar <span class="fu">=</span> <span class="kw">do</span>      <span class="co">-- &lt;5&gt;</span>
    tail <span class="ot">&lt;-</span> new                         <span class="co">-- &lt;6&gt;</span>
    put var (<span class="dt">Cons</span> x tail)               <span class="co">-- &lt;7&gt;</span>
    loop (n <span class="fu">-</span> <span class="dv">1</span>, k <span class="fu">-</span> <span class="dv">1</span>) xs tail nVar    <span class="co">-- &lt;8&gt;</span></code></pre>
<p><code>n == 1</code> のときも簡単。これは指定された数のチャンクを生産し終わった時なので、再帰を停止すればよい。ただ、再帰をやめるのにあたり、新しい<code>IVar</code>をここで生成してしまうと、この<code>IVar</code>へ値を<code>put</code>してくれるワーカーがどこにもいなくなってしまう。そこで前述した <code>loop</code> へ追加した最後の引数を使う。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  loop (<span class="dv">1</span>, _) (x<span class="fu">:</span>_) var (<span class="dt">Just</span> next) <span class="fu">=</span> put var (<span class="dt">Cons</span> x next)</code></pre>
<p>この <code>next</code> は、次のchunkの生産時に結果を <code>put</code> する <code>Stream</code> の先頭要素である。なので、消費者側はこの <code>next</code> を <code>get</code> することで続きのデータが得られる。</p>
<p><code>k == 0</code> の時が次のchunkの生産を <code>fork</code> すべきときで、ここで <code>loop</code> の最後の引数も作る必要がある。あと、 <code>Fork</code> は <code>Cons</code> も兼ねているので、通常の <code>Cons</code> を生成する場合の処理も必要となる。 <code>nVar</code> が次のchunkの結果を含む<code>Stream</code>の先頭で、これを <code>loop</code> で引き回して今のchunkの生産が終わったら <code>nVar</code> へ繋げてやる。<code>fork</code>する際、現在のワーカーが残り <code>n - 1</code> 個の生産をする予定のはずなので、それらは <code>drop</code> でリストから捨ててやる。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  loop (n, <span class="dv">0</span>) (x<span class="fu">:</span>xs) var <span class="dt">Nothing</span> <span class="fu">=</span> <span class="kw">do</span>
    tail <span class="ot">&lt;-</span> new
    nVar <span class="ot">&lt;-</span> new
    put var (<span class="dt">Fork</span> (kick (drop (n <span class="fu">-</span> <span class="dv">1</span>) xs) nVar)
                  (<span class="dt">Cons</span> x tail))
    loop (n <span class="fu">-</span> <span class="dv">1</span>, <span class="fu">-</span><span class="dv">1</span>) xs tail (<span class="dt">Just</span> nVar)

  kick xs var <span class="fu">=</span> loop (chunkSize, forkPoint) xs var <span class="dt">Nothing</span></code></pre>
<p>ここまでできてしまえば、 <code>streamMap</code> は生産者と消費者の両方の役割を兼ねるだけなのでさくっと実装できるかと思うが、実はそうはいかない。 <code>streamFromList</code> はlistを相手にしていたために <code>Fork</code> を消費者へ渡す時点で次のchunkがどの要素から生成を始めればよいかがわかったが、言語今回は入力が <code>Stream</code> なので上流からの値を <code>chunkSize</code> 個すべて受け取るまでは次のchunkの対象とすべき要素が確定しない。</p>
<p>この問題を解決するには、 <code>loop</code> の最後の引数を <code>Maybe (IVar (IVar (IList a), IVar (IList b)))</code> というように入れ個の <code>IVar</code> に変えてやるとよい。そして、現在のforkが<code>chunkSize</code>個のデータの生産を終えた時点で、次のforkに対して入力と出力の2つの <code>Stream</code> を表す <code>IVar</code> を伝えてやればよい。</p>
<p><code>Fork</code>を要求する側は、だいたいこうなる(<code>Nil</code> は再帰を終えるので自明、<code>Fork</code>を消費する部分は<code>Cons</code>の消費と同じなので、それぞれ省略している)。次のchunkの入出力の先頭を表す<code>Stream</code>を受け取るために <code>nextstrm</code> という <code>IVar</code> を生成し、これを <code>loop</code> の引数としてchunkの末尾まで引き回している。chunkの末尾までいって対象となる <code>Stream</code> が確定した時点で、<code>(instrm, outstrm) &lt;- get var</code> と結果を受け取って次のchunkの処理を開始する。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  loop (n, <span class="dv">0</span>) instrm outstrm <span class="dt">Nothing</span> <span class="fu">=</span> <span class="kw">do</span>
    ilst <span class="ot">&lt;-</span> get instrm
    <span class="kw">case</span> ilst <span class="kw">of</span>
<span class="fu">...</span>(snip)<span class="fu">...</span>
      <span class="dt">Cons</span> h t <span class="ot">-&gt;</span> <span class="kw">do</span>
        newtl <span class="ot">&lt;-</span> new
        nextstrm <span class="ot">&lt;-</span> new
        put outstrm (<span class="dt">Fork</span> (kick' nextstrm)
                          (<span class="dt">Cons</span> (fn h) newtl))
        loop (n <span class="fu">-</span> <span class="dv">1</span>, <span class="fu">-</span><span class="dv">1</span>) t newtl (<span class="dt">Just</span> nextstrm)
<span class="fu">...</span>(snip)<span class="fu">...</span>

  kick instrm outstrm <span class="fu">=</span> loop (chunkSize, forkPoint) instrm outstrm <span class="dt">Nothing</span>
  kick' var <span class="fu">=</span> <span class="kw">do</span>
    (instrm, outstrm) <span class="ot">&lt;-</span> get var
    kick instrm outstrm</code></pre>
<p>chunkの末尾でやることは、だいたい以下の通り。次のchunkの入力の先頭である <code>tail</code> がここで確定し、また、出力を書き込むために <code>newtl</code> という新たな <code>Stream</code> を生成し、 <code>loop</code> の末尾の引数を使って次のchunkにそれらを伝えると共に、消費者には続きを得るために <code>newtl</code> を返している。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  loop (<span class="dv">1</span>, _) instrm outstrm (<span class="dt">Just</span> next) <span class="fu">=</span> <span class="kw">do</span>
    ilst <span class="ot">&lt;-</span> get instrm
    <span class="kw">case</span> ilst <span class="kw">of</span>
<span class="fu">...</span>(snip)<span class="fu">...</span>
      <span class="dt">Cons</span> h tail <span class="ot">-&gt;</span> <span class="kw">do</span>
        newtl <span class="ot">&lt;-</span> new
        put next (tail, newtl)
        put outstrm (<span class="dt">Cons</span> (fn h) newtl)
<span class="fu">...</span>(snip)<span class="fu">...</span></code></pre>
<p>この実装でthreadscopeをとると以下のようになった。本に載っていたサンプルは消費者の方が速いタイプだったので本件の実装が正しく働いているかは判断できないが、きちんと並列に動作していることは見て取れる。<code>fork</code> の回数が増えたことで、コアは2つだけではなくすべてがまんべんなく使われるようになった。</p>
<div class="figure">
<img src="./images/2014-09-14-rsa-pipeline.png" alt="threadwatch" /><p class="caption">threadwatch</p>
</div>
<p>完全な実装は<a href="https://github.com/hiratara/parconc-examples/commit/639abe2cad1fc3529313981ede51d5364126c115">githubの方</a>を参照して欲しい。ただし、面倒だったので本に載っていない <code>streamFilter</code> の方は改修していないので使えない(<code>fork</code>しないので最初のchunkで止まる)。</p>

</div>



<div>
  <h1><a href="./posts/2014-09-03-YAPCAsia2014_rejects.html">今日は YAPC::Asia 2014 Reject con の日です</a></h1>

<div class="info">
    Posted on September  3, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-09-03-YAPCAsia2014_rejects.html" data-text="今日は YAPC::Asia 2014 Reject con の日です" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-09-03-YAPCAsia2014_rejects.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<p><a href="http://www.zusaar.com/event/14507005">YAPC::Asiaのreject con</a>に参加します。自分用に執ったメモを公開しておきます。</p>
<h2 id="papix__さん-オープニング"><span class="citation">@__papix__さん</span> / オープニング</h2>
<ul>
<li>トークで落ちて悔しいって言ってたら開催の運び</li>
<li>悔しい5人と飛び入りLT</li>
<li>乾杯！</li>
</ul>
<h2 id="ytnobody-tsucchi-さんこれはormですか-いいえotogiriです---基礎編"><span class="citation">@ytnobody</span> &amp; <span class="citation">@tsucchi</span> さん｢これはORMですか? いいえOtogiriです - 基礎編｣</h2>
<h3 id="ytnobodyさん"><span class="citation">@ytnobodyさん</span></h3>
<ul>
<li>これゾン関係ない</li>
<li>DBIx::Sunny + SQL::Maker</li>
<li>ORM
<ul>
<li>車輪の再発明。麻疹の一種</li>
</ul></li>
<li>動機
<ul>
<li>TengはSchema書くのがおっくう</li>
<li>TengはSchema::Dumperで自動生成できる</li>
<li>自動生成されたコードに TYPE =&gt; 4 みたいなマジックナンバーが</li>
<li>SQL::Translator::Producer::Teng でよくなる</li>
<li>テーブル変更頻繁だし、そこに手間かけたくない</li>
</ul></li>
<li>OogiriはSchmaがないので、面倒事がない
<ul>
<li><code>strict =&gt; 0</code> を指定しないと、Hash-refが食わせられなかったり</li>
<li>select, updateはTengっぽい</li>
<li>transactionやinflateのサポート</li>
</ul></li>
<li>デフォルトではstrict 1
<ul>
<li>decode_json したものは食わせられない</li>
<li>SQL::QueryMakerが提供する関数群がexportされるので、それを使う</li>
</ul></li>
<li>行数少ない。合計で200行以下</li>
</ul>
<h3 id="tsucchiさん-otogiriの話応用編"><span class="citation">@tsucchiさん</span> Otogiriの話応用(?)編</h3>
<ul>
<li>SQL::Executor みたいの作ってた
<ul>
<li>似てるけど、DBIx::Sunnyベースじゃない</li>
<li>一年くらいOtogiriに乗っかってる</li>
</ul></li>
<li>Otogiri::Plugin
<ul>
<li><code>Otogiri::Plugin::DeleteCascade</code> → FKを辿って親も消す。<code>delete_cascade()</code></li>
<li>Otogiriの名前空間にメソッド生やす</li>
<li>TableInfo (show tables), BulkInsert, WueryWithNamedPlaceholder</li>
</ul></li>
<li>OtogiriとReplyの組み合わせ
<ul>
<li>Reply は irb 的なの。repl</li>
<li>Otogiri::Plugin::DataDumperAutoEncode → 自動でエンコード</li>
<li>Reply::Plugin::ORM → Reply環境でotogiriが使える</li>
</ul></li>
<li>デモ
<ul>
<li>TableInfo, Desc, Selectの例</li>
<li>Delete_cascadeも便利</li>
</ul></li>
<li>oracleのクライアントの代わりに使ったりinflateと組み合わせると便利かもね</li>
<li>今後
<ul>
<li>Pluginで便利なものはコアに引き上げたいな</li>
<li>Pluginのグルーピングしたいな</li>
</ul></li>
<li>質疑応答
<ul>
<li>Q. Tengのスキーマローダーとか使えばいい。O/Rマッパー書く人なら知ってるよね (<a href="https://twitter.com/tokuhirom/status/507129417852674049">ニュアンス違いそうです</a>、すみません)</li>
<li>A. 麻疹なんで</li>
</ul></li>
</ul>
<h2 id="papix__-さん帰ってきたpercuda-perlとgpgpuが出会い-そして未来へ"><span class="citation">@__papix__</span> さん｢帰ってきたPerCUDA 〜PerlとGPGPUが出会い, そして未来へ〜｣</h2>
<ul>
<li>画面つながらない → 再起動したら直った！</li>
<li>1年前にPerCUDA構想の話をした
<ul>
<li>PerlのコードのみでGPGPUをつくろうとした</li>
<li>一ヶ月でできた→卒業</li>
<li>職質テックトークのmoznionさんの会を参照</li>
</ul></li>
<li>YAPCのトークで落選した</li>
<li>GPGPUへの注目
<ul>
<li>64〜128個のコア「今は4000以上あるよ！ちゃんと調べて！！」</li>
<li>EC2でもある（高い）</li>
</ul></li>
<li>CUDA、OpenCLなどがある
<ul>
<li>静的型付けになっちゃう</li>
<li>知識必要</li>
</ul></li>
<li>スクリプト言語でのマッピング (Ruby、Python、Perlなど)
<ul>
<li>楽なんじゃね？</li>
<li>PyCUDA、Pynvvm は有名</li>
<li>ParaRuby, Ikra(RubyコードからCを自動生成</li>
</ul></li>
<li>Perl
<ul>
<li>KappaCUDA、ExtUtils::nvcc、OpenCL、CUDA::Minimal</li>
<li>PerCUDA → PerlのコードをGPUコードに自動変換
<ul>
<li>GPUないときは、pure perlで実行(MBAにはないよ)</li>
<li>1200倍高速に！</li>
</ul></li>
</ul></li>
<li>CPU側処理とGPU側処理を切り分けて実装する必要
<ul>
<li>CPUとGPUのメモリが共通ではないので</li>
</ul></li>
<li>CUDA
<ul>
<li>NVIDIAが提供するGPGPUフレームワーク</li>
<li>CUDA C言語とCUDA API</li>
<li>NVCCコンパイラもある</li>
<li>llvmを使ってるので、通常のCやFortranでも使える</li>
</ul></li>
<li>LLVM
<ul>
<li>Clang</li>
<li>LLVM IRを介すので、言語、アーキテクチャに依存しない</li>
<li>変換フェーズでの最適化がいい感じ</li>
</ul></li>
<li>Compiler::CodeGenerator::LLVM → Perl コードをLLVM IRへ
<ul>
<li>使えない構文が多いので見送り</li>
</ul></li>
<li>PerCUDA
<ul>
<li>変換系と実行系にわかれている</li>
<li>PTXに変換して、GPU実効しない場合はPerlの通常の関数を呼ぶ</li>
<li>正規表現でCに変換している(！)</li>
<li>GPUでじっこうした結果をまたPerlでラップする</li>
<li>CUDAのAPIでGPUを操作</li>
</ul></li>
<li>1024x1024の行列の乗算は1000倍以上(生CUDAの方が5倍くらい速いけど)
<ul>
<li>Perlのデータ変換が遅い</li>
</ul></li>
<li>極悪な正規表現があっても大学院は終了できる</li>
<li>今後
<ul>
<li>GPUの値段が下がっている</li>
<li>Imager的なものをGPUでやろうとしてたけど</li>
<li>GPGPU坂をよ</li>
</ul></li>
<li>質疑応答
<ul>
<li>Q. OpenCLの予定は？</li>
<li>A. ないです</li>
<li>Q. 型あまりよくないですよ</li>
<li>A. 型ないと動かないですよ</li>
<li>Q. あの正規表現ずっとあるんですけどなんとかならないですか</li>
<li>A. 時間がなかったのです</li>
</ul></li>
</ul>
<h2 id="punytan-さんmodel-layer-development-tips"><span class="citation">@punytan</span> さん｢Model Layer Development Tips｣</h2>
<ul>
<li>バリデーション、DB、テストをなんとかする</li>
<li>バリデーション
<ul>
<li>Mouse::Util::TypeConstraints</li>
<li>subtypeを使って、文字列や自然数などを</li>
</ul></li>
<li>Data::Validatorを使うとよい</li>
<li>Internals::SvREADONLY は悲しいことになる
<ul>
<li>NoRestricted を使うといい</li>
<li>ないキーにアクセスすると落ちる</li>
<li>「それをチェックしたいからそうしてるのでは」「xorとかしているときは厳しい」</li>
</ul></li>
<li>SQLの生成にはSQL::Formatを使う</li>
<li>DBIx::HandlerでDBに接続する
<ul>
<li>コネクションハンドリング、scopeベース</li>
<li>fork safeなのでpreforkの時は必須</li>
<li>txnメソッドでトランザクション</li>
</ul></li>
<li>DBIのマニアックなメソッド
<ul>
<li>selectrow_<em>ref, selectall_</em>ref</li>
</ul></li>
<li>DBIx::QueryLog
<ul>
<li>開発中に、どんなクエリを出してるか見る</li>
<li>colorとかcompactとかexplainは便利</li>
</ul></li>
<li>テスト → コンパイル、データ、prove、高速化
<ul>
<li>Test::LoadAllModules → 全部ロードしてコンパイルチェック</li>
<li>Test::MOre、Test::Deep、Test::Deep::Matcher → データのチェック
<ul>
<li>superhashofとか</li>
</ul></li>
<li>Test::Pretty → proveの結果を見やすく。<code>prove -Pretty</code></li>
<li>Test::Docker::MySQL → Dockerコンテナでテストを速く
<ul>
<li><code>$guard-&gt;get_port</code> でおｋ</li>
<li>スキーマやフィクスチャを事前用意しておくとよい</li>
</ul></li>
</ul></li>
<li>Alpaca.pm
<ul>
<li>モデルフレームワーク</li>
<li>Proof of Conceptを実装</li>
<li>モデルにフォーカス</li>
<li>大量のデータベースを扱える(スケーラブル)</li>
<li>ビルトインのテストフレームワーク</li>
</ul></li>
<li>例えば、ブログの記事の読み込み
<ul>
<li>DB定義、型のバリデーション、ロジックを書く</li>
<li>テスト → テーブルロード、実行</li>
<li>cmpとかis_deeplyとかはデータのdumpがでなくて不便</li>
<li>スロークエリのハイライトとか</li>
<li>kamipoさんがmysql casualで話してたアレ（？）を使いたい</li>
</ul></li>
<li>デモ → さっきまでは動いてたんだけど</li>
<li>質疑応答
<ul>
<li>Q. Test::DockerMysqlDは使ってます?</li>
<li>A. 今はまだ。使えると思う</li>
<li>Q. セットアップが面倒なのはどうする？</li>
<li>A. 頑張る</li>
<li>Q. Test::Prettyを使うと壊れてしまうようなテストはどうする？</li>
<li>A. そういうときはTest::Prettyを使わない</li>
</ul></li>
</ul>
<h2 id="xtetsuji-さん今に伝えるメールの技術"><span class="citation">@xtetsuji</span> さん｢今に伝えるメールの技術｣</h2>
<ul>
<li>みんな飲んでますか
<ul>
<li>「平成生まれはメール使わないでしょ？」</li>
<li>「DISは許しません」</li>
<li>「xtetsujiです。xtetsujiです。よろしくお願いします」</li>
<li>mod_perl職人から、メールで勝負</li>
<li>トーク落ちたので・・・</li>
</ul></li>
<li>AnyEventを封じられたのでmod_perlでSMTPサーバ作った経験</li>
<li>メールを取り巻く
<ul>
<li>SPAM、未読、SMTPがシンプルじゃない、POP3もIMP4も面倒、社内でも使わない</li>
</ul></li>
<li>Sがシンプルじゃない問題
<ul>
<li>SOAPの例「(Sは)現状は何かの頭文字ではないとされている」</li>
</ul></li>
<li>gmailのせいで社内のメールサーバがなくなってきてる
<ul>
<li>ガラケーが消えたのも大きい</li>
<li>IM、チャットの台頭</li>
</ul></li>
<li>「シニアエンジニアによるガラケー大戦回顧録」というイベント
<ul>
<li>ひろ＊ちゅさんにretweetされてバズった</li>
<li>インデックスさんの倒産にちなんで</li>
</ul></li>
<li>ガラケーとメールの関係
<ul>
<li>空メという文化</li>
<li>通知もメール</li>
</ul></li>
<li>メールが使われないとまずい
<ul>
<li>メールの技術が継承されない</li>
</ul></li>
<li>MTA : Mail Transfer Agent
<ul>
<li>今は Postfix を選ぶといい</li>
<li>バージョンアップが激しい(最新版は2.11.1)</li>
<li>日本Postfix友の会(新宿のロイホで作った) → 活動したい</li>
<li>Postfixのページ postfix-jp.info も更新が止まってる ← 叩き潰したい</li>
</ul></li>
<li>SMTPを手でしゃべる
<ul>
<li>telnet localhost 25</li>
<li>PerlならNet::SMTP (コアモジュール)</li>
<li>RCPT TOで拒否されるのとDATAで拒否されるのと複数パターン
<ul>
<li>前者は指定拒否されてる場合。後者はspam判定</li>
</ul></li>
</ul></li>
<li>Email::Sender Moose依存からMoo依存に変わった
<ul>
<li>ラッパーを作ってます</li>
<li>「Tegami」とか予定</li>
</ul></li>
<li>受信
<ul>
<li>Postfixのpipeを使う</li>
<li>.forwardにかいたりmaster.cfにサービスとして書いたり</li>
</ul></li>
<li>メルマガの消し込み
<ul>
<li>エラーメールをプログラムで受信して配信しないようにする</li>
<li>master.cf使ったほうがエンベロープfromがもらえるので便利</li>
<li>受け取り時に落ちないように</li>
</ul></li>
<li>Qpsmtpd
<ul>
<li>Perl製のメールサーバ</li>
<li>forkする感じでもない</li>
</ul></li>
<li>エラー文面の文面の解析
<ul>
<li>bounceHammer(perl製)で</li>
</ul></li>
<li>メルマガ大量配信
<ul>
<li>外部に任せるといい</li>
<li>サーバとIPアドレスを並べる</li>
</ul></li>
<li>fml4はperl5.10で動かなくなった
<ul>
<li>fml8プロジェクトが後継。普及しない</li>
<li>Python製のMailmanが普及だけど、使いにくい</li>
</ul></li>
<li>絵文字
<ul>
<li>Encode::JP::MobileやUnicode::Japanese</li>
<li>今ではEncodeモジュール</li>
</ul></li>
<li>ガラケーから絵文字
<ul>
<li>下駄になる</li>
<li>LINE使ったほうが早いよ！</li>
</ul></li>
<li>メールの技術はロストテクノロジー化したけど、生き残るはず</li>
<li>「メールは滅びぬ」</li>
</ul>
<h2 id="saisa6153-さん-今から始めるレガシーコード改善レポート"><span class="citation">@saisa6153</span> さん ｢今から始めるレガシーコード改善レポート｣</h2>
<ul>
<li>レガシーは資産、遺産
<ul>
<li>legacy system だと古くなったもの的な意味になる</li>
</ul></li>
<li>新しい技術 → 高速になる。新しい脆弱性も出る</li>
<li>ユーザーが必要とするので止められない</li>
<li>新しくなることのメリット
<ul>
<li>0.1秒遅いと1%売上ダウン、0.5秒遅くなると20%検索数がダウン</li>
<li>セキュリティをないがしろにするリスク</li>
<li>でも、そこまでメリットある？</li>
</ul></li>
<li>あなたがレガシーと思うものがレガシーである
<ul>
<li>エンジニア、顧客、エンドユーザ、マネージャ → 関わる人はひとりじゃない</li>
<li>古くてもいいという人も多い(XP)</li>
<li>深夜の不在着信は辛い</li>
</ul></li>
<li>ハードウェア、ソースコードは勝手に変わったりしない
<ul>
<li>ただし、システムをとりまく環境は常に変わる</li>
<li>システムも世界の変化についていかなければならない→ついていけないものがレガシー</li>
</ul></li>
<li>レガシーはダメか
<ul>
<li>問題はおおい</li>
<li>コストを考える必要 → お金がない。競合に勝つスピード。</li>
<li>次々と現れる新技術</li>
<li>レガシーの方がコストが高い、となる機運が高まった時に手を付ける</li>
</ul></li>
<li>題材: システムPerl。Catalyst。1億PV
<ul>
<li>顧客ごとのカスタマイズ(コピペ。リポジトリが別(git + subversion)ネットワークごとフォーク)</li>
<li>OSやMiddle Wareが古すぎる。仮想化するとなぜかトラブル</li>
<li>サーバごとにCPANバージョン違う。プロダクトコードがサーバ内でのみ弄られてる（！）</li>
<li>シンボリックリンクの多用。NFS</li>
<li>バッチが終わらない。止まる、リトライ負荷</li>
<li>コードスタイルが違いすぎる。modelが薄い。テストがない。マイグレーションって何？</li>
</ul></li>
<li>「Perlに起因するレガシーさはない」
<ul>
<li>Googleとかで見るとトレンド下がってるけど</li>
<li>「衰退してるのは僕らだった」</li>
<li>レガシーさの判断、同僚に判断、優先順位付け（全部は無理）</li>
<li>見切り発車で失敗すると次はない→慎重に</li>
</ul></li>
<li>プロダクトのフォークの問題
<ul>
<li>可能な限り合わせる</li>
<li>デベロップブランチで運用されているサーバの修正(顧客と調整)</li>
</ul></li>
<li>次の手
<ul>
<li>バッチを減らす</li>
<li>Git化</li>
<li>GitDDL::Migrator</li>
<li>Test:mysqld</li>
<li>バッチは手を出しやすい</li>
</ul></li>
<li>さらに次の予定
<ul>
<li>テストの導入、規約、Ansibleの導入</li>
</ul></li>
<li>一番つらかったところ
<ul>
<li>どこから手を出すのかわからない</li>
<li>障害やバグの割り込みが多い</li>
<li>モチベーションが上がらない
<ul>
<li>新しいものを生み出していない後ろめたさ</li>
</ul></li>
</ul></li>
<li>「技術的負債を倍返しするイメージ」「前任者は殉職した」と考えるのがいい</li>
<li>どうするべきだった（どうするべき）
<ul>
<li>CI/CD環境は重要</li>
<li>コマンド1つでデプロイできるようになってから開発スタート</li>
<li>コーディング規約、設計方針、バージョン管理</li>
<li>引き継ぎへの備え（組織でやる以上仕方ない）</li>
<li>開発完了（運用開始前）までに問題を解決しておく</li>
<li>OSやMiddlewareをアップデートする状態は維持</li>
</ul></li>
<li>辛くなったらグリーンフィールド(政治的、技術的制約のないプロジェクト)に関わる</li>
<li>良かった点
<ul>
<li>良くなってるという実感がある</li>
<li>最近のプロジェクトはモダンになってるので希望はある</li>
<li>マイナスを0にするのも、大事、と考える</li>
<li>反面教師として使える</li>
</ul></li>
<li>これからレガシーシステムに向かう人
<ul>
<li>直す意義を考えてビジネスサイドを動かす</li>
<li>見方を見つける</li>
<li>業務との平行は避ける</li>
</ul></li>
</ul>
<h2 id="ltタイム">LTタイム</h2>
<h3 id="mala-さんhow-to-hack-metacpan.org"><span class="citation">@mala</span> さん「How to hack metacpan.org」</h3>
<ul>
<li>metacpan.orgでremote code executionができた
<ul>
<li>Plack::MiddleWare::Session::Cokkie miyagawaさんが長足でリリースした</li>
<li>metacpanは遅かった</li>
</ul></li>
<li>Storableオブジェクト
<ul>
<li>任意のクラスのオブジェクトを復元できてしまう</li>
<li>改ざんcokkieを送ってデシリアライズのタイミングでコード実行できてしまう</li>
<li>HTTP::Session2 + Amon2 でも</li>
</ul></li>
<li>オブジェクトが復原されるということは、初期化処理、デストラクタの処理
<ul>
<li>オブジェクトでシリアライザは危険</li>
<li>blessed hashは気軽に使わない</li>
<li>JSONは？ → SQL injectionにつながることも</li>
<li>overload 付けておくと、関連オブジェクトを読んでしまったり</li>
</ul></li>
<li>Storableのドキュメントに信頼できないものはだめって書かれた
<ul>
<li>デストラクタ実行ではできることは限られる</li>
<li>デストラクタでコード実行できそうなものを探す</li>
<li>ファイルへの書き込み → あった！ (目grepで探す)
<ul>
<li>ログとか、自動セーブ</li>
</ul></li>
</ul></li>
<li>デモ : ローカルで動かすmetacpan
<ul>
<li>任意ファイルへの書き込みを利用して、トップページをdankogaiさんに書き換え</li>
</ul></li>
<li>Storableのコード実行は危険
<ul>
<li>コアのLWPに付属したものでそういうのがある</li>
<li>情報の公開が適切か、相談中</li>
</ul></li>
<li>Amon2とPlack::Middleware::Sessionの該当バージョンを使ってる人は要対応</li>
</ul>
<h3 id="note103-さんはじまりのperl"><span class="citation">@note103</span> さん「はじまりのPerl」</h3>
<ul>
<li>音楽系の編集者</li>
<li>THE FRENCH REVOLUTION (共著) → 編集DTPの基礎</li>
<li>坂本さんのJ.S.Bachなど</li>
<li>2008年の仕事
<ul>
<li>YAPCがやってた</li>
<li>YAPCをTwitterで追いかけていた</li>
<li>Perl Is unDeadが印象に残っていた</li>
</ul></li>
<li>面白いこと言う人はエンジニアだと思った</li>
<li>初心者はいくら手を動かしてもわからない</li>
<li>実践vimを献本企画で当選（異業種からで優遇）</li>
<li>YAPC::Asia 2013のearly bird
<ul>
<li>これは出なかった</li>
</ul></li>
<li>Perl入学式に出会う
<ul>
<li>打ちのめされた</li>
<li>moznionさんが「こんな感じだった」</li>
</ul></li>
<li>最後まで参加して、サポーターになった
<ul>
<li>Perl入学式でハマったところをブログに</li>
<li>vimについても書いた</li>
</ul></li>
<li>振られて引き受けてはいたけど、選択は自分でしていた</li>
<li>Acme::revealupのお陰でスライド使えた
<ul>
<li>作りすぎた</li>
</ul></li>
</ul>
<h3 id="karupanerura-さんworkman"><span class="citation">@karupanerura</span> さん「Workman」</h3>
<ul>
<li>Workman – job que worker – gearman から q4mに変更するのが辛い→できるように – preforkはシグナルつかって辛い→よしなに</li>
<li>デモ : ワークマンのCMを流しながら – 「透けてるターミナル初めて便利だと思った」 – Fileをqueとして使っている例 – gearmanに切り替える – 強制終了時にどういう処理をするか、例外を書く感じで書ける – 「本当は動くはずです」</li>
</ul>
<h3 id="xaicron-さんハッカドール作りました仮"><span class="citation">@xaicron</span> さん「ハッカドール作りました(仮)」</h3>
<ul>
<li>「史上空前のプレゼンをしてやるぜ」</li>
<li>これをこの場に入れてくれた人にシールプレゼント(残り10枚)
<ul>
<li>美少女モバゲーのパンフレットも</li>
</ul></li>
<li>「欲しいー」「ま、あげないんだよね」</li>
<li>ハッカドールのプロモーションビデオを鑑賞
<ul>
<li>(小道具にペンライトが)</li>
<li>RECOMENDATION のスペルが間違えている(修正依頼中)</li>
<li>動画のラストにxaicronさんの名前が入ってる</li>
</ul></li>
<li>最近の仕事
<ul>
<li>声優の選定、声優の収録、アニサマ</li>
<li>YAPC行きたかったけど仕事だったので仕方ない</li>
</ul></li>
<li>声優ソムリエさいくろん → 17歳くらいの娘ときゃっきゃうふふ
<ul>
<li>Perlは歴史ある言語なので、やってるとこういう仕事もある</li>
<li>弊社に入るとこういう仕事ができる可能性が</li>
</ul></li>
<li>YAPCで話すつもりだったけどめんどくさくなった</li>
</ul>
<h3 id="kamipo-さん無題"><span class="citation">@kamipo</span> さん「(無題)」</h3>
<p>飛び入りです。</p>
<ul>
<li>座れなかったとか → カンファレンスは廊下でその辺の人捕まえるのが本来</li>
<li>tokuhiromさん「issueが放置されてるので声かけて下さい」→ 声かけたほうがいいよ</li>
<li>xaicronさんにお願いしたらマージしてくれた
<ul>
<li>YAPC終わりました</li>
</ul></li>
<li>質疑応答
<ul>
<li>Q. 小指どうしたの？</li>
<li>A. どうもなってないけど</li>
<li>Q. ニセモノ？</li>
<li>A. あったまってなかった</li>
</ul></li>
</ul>
<h3 id="papix__-さんクロージング"><span class="citation">@__papix__</span> さん「クロージング」</h3>
<ul>
<li>(余ったピザを食べながら)「チーズが美味しい」</li>
<li>yusukebeさんとmyfinderさんのおかげでした</li>
<li>ビールなくなるまではどうぞ(後片付けは気にしつつ)</li>
</ul>

</div>



<p>…or you can find more in the <a href="./archive.html">archives</a>.

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
