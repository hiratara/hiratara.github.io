<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Born in Tomakomai city - Top</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <!-- Google Analytics tracking codes -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-7637699-4', 'hiratara.github.io');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <!-- facebook SDK -->
        <div id="fb-root"></div>
        <script>(function(d, s, id) {
          var js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s); js.id = id;
          js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=100848266724416";
          fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script>

        <div id="header">
            <div id="logo">
                <a href="./">Born in Tomakomai city</a>
            </div>
            <div id="navigation">
                <a href="./">Top</a>
                <a href="./about.html">About</a>
                <a href="./contact.html">Contact</a>
                <a href="./archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            

<div>
  <h1><a href="./posts/2014-06-14-llvm.html">llvm memo</a></h1>

<div class="info">
    Posted on June 14, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-06-14-llvm.html" data-text="llvm memo" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-06-14-llvm.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<pre><code>*.c -[clang]-&gt; *.ll -[llvm-as]-&gt; *.bc -[opt]-&gt; *.bc -[llc]-&gt; *.s, *.o
                                                    -[lli]-&gt; EXECUTE</code></pre>

</div>



<div>
  <h1><a href="./posts/2014-05-18-logistic.html">二値変数だけからなるロジスティック回帰</a></h1>

<div class="info">
    Posted on May 18, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-05-18-logistic.html" data-text="二値変数だけからなるロジスティック回帰" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-05-18-logistic.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<p>説明変数が複数の二値変数からなり、目的変数が二値をとるロジスティック回帰を考える。</p>
<p><span class="math">\(\bf{w}\)</span>をウェイト、<span class="math">\(\bf{x}_n\)</span>と<span class="math">\(t_n\)</span>を学習データとする。確率的勾配降下法を用いれば、以下のよく見る式で都度重みを更新できる。 ただし、<span class="math">\(y_n\)</span>は<span class="math">\(\bf{w}^{(i)}\)</span>による<span class="math">\(\bf{x}_n\)</span>に対する予測値で、<span class="math">\(\eta\)</span>は1未満の正の定数。</p>
<p><span class="math">\[\bf{w}^{(i+1)} = \bf{w}^{(i)} - \eta ( y_n - t_n ) \bf{x}_n \]</span></p>
<p>二値を0、1とすれば、説明変数は疎ベクトルとなる可能性がある。この場合、ハッシュで表すと空間効率が良い。 定数項を含めるため、<span class="math">\(\bf{w}\)</span>、<span class="math">\(\bf{x}\)</span>にそれぞれ“bias”という項を設け、常に<span class="math">\(1\)</span>で入力するようにする。</p>
<p>例えば説明変数が2次元の場合、取りうる値は<span class="math">\((0, 0), (1, 0), (0, 1), (1, 1)\)</span>の4つしかないので、 それぞれの点での値とマッチするようにフィッティングされる。<span class="math">\(N\)</span>次元の場合は、<span class="math">\(2^N\)</span>個の等式ができるが、 パラメータ<span class="math">\(\bf{w}\)</span>の数は定数項を入れて<span class="math">\(N + 1\)</span>個であるので、対数尤度を最大にするようにパラメータを 決めなければならないというのは通常のロジスティック回帰と変わらない。</p>
<p>perlでさくっと実装すれば以下のような感じ。説明変数が10010次元あり(よって、ウェイトは定数項を入れて10011次元)、それぞれの入力に対して1となる 確率を予測している。</p>
<pre class="sourceCode perl"><code class="sourceCode perl"><span class="fu">use</span> <span class="kw">strict</span>;
<span class="fu">use</span> <span class="kw">warnings</span>;
<span class="fu">use</span> <span class="fu">List::Util</span> <span class="kw">qw(</span>shuffle<span class="kw">)</span>;

<span class="kw">sub </span><span class="fu">logit</span> (<span class="dt">$</span>) {
    <span class="dv">1</span> / (<span class="dv">1</span> + <span class="fu">exp</span>(- <span class="dt">$_</span>[<span class="dv">0</span>]));
}

<span class="kw">sub </span><span class="fu">dot</span> (<span class="dt">$$</span>) {
    <span class="kw">my</span> (<span class="dt">$w</span>, <span class="dt">$x</span>) = <span class="dt">@_</span>;
    <span class="kw">my</span> <span class="dt">$p</span> = <span class="dv">0</span>;
    (<span class="fu">exists</span> <span class="dt">$w</span>-&gt;{<span class="dt">$_</span>} <span class="kw">and</span> <span class="dt">$p</span> += <span class="dt">$w</span>-&gt;{<span class="dt">$_</span>} <span class="kw">*</span> <span class="dt">$x</span>-&gt;{<span class="dt">$_</span>}) <span class="kw">for</span> <span class="fu">keys</span> %<span class="dt">$x</span>;
    <span class="dt">$p</span>;
}

<span class="kw">sub </span><span class="fu">predict</span> (<span class="dt">$$</span>) {
    <span class="kw">my</span> (<span class="dt">$w</span>, <span class="dt">$x</span>) = <span class="dt">@_</span>;
    logit(dot(<span class="dt">$w</span>, <span class="dt">$x</span>));
}

<span class="kw">sub </span><span class="fu">train</span> (<span class="dt">$$$$</span>) {
    <span class="kw">my</span> (<span class="dt">$w</span>, <span class="dt">$x</span>, <span class="dt">$t</span>, <span class="dt">$eta</span>) = <span class="dt">@_</span>;
    <span class="kw">my</span> <span class="dt">$pred</span> = predict(<span class="dt">$w</span>, <span class="dt">$x</span>);
    <span class="kw">for</span> (<span class="fu">keys</span> %<span class="dt">$x</span>) {
        <span class="dt">$w</span>-&gt;{<span class="dt">$_</span>} -= (<span class="dt">$pred</span> - <span class="dt">$t</span>) <span class="kw">*</span> <span class="dt">$eta</span> <span class="kw">*</span> <span class="dt">$x</span>-&gt;{<span class="dt">$_</span>};
    }
}

<span class="co"># Use random grouping</span>
<span class="co"># {</span>
<span class="co">#     my %groups = map { $_ =&gt; int(rand(10)) } 0 .. 9999;</span>
<span class="co">#     sub group_of_subgroup ($) { $groups{$_[0]} }</span>
<span class="co"># }</span>
<span class="kw">sub </span><span class="fu">group_of_subgroup</span> (<span class="dt">$</span>) { <span class="fu">int</span>(<span class="dt">$_</span>[<span class="dv">0</span>] / <span class="dv">1000</span>) }

<span class="kw">sub </span><span class="fu">build_subgroup</span> (<span class="dt">$</span>) {
    <span class="kw">my</span> <span class="dt">$n</span> = <span class="fu">shift</span>;
    <span class="kw">my</span> <span class="dt">$rate</span> = <span class="fu">int</span>(<span class="dt">$n</span> / <span class="dv">1000</span>) + <span class="dv">1</span>;
    <span class="kw">my</span> <span class="dt">$group</span> = group_of_subgroup <span class="dt">$n</span>;
    (<span class="dt">$rate</span>, {
        <span class="kw">&quot;</span><span class="st">subgroup</span><span class="dt">$n</span><span class="kw">&quot;</span>  =&gt; <span class="dv">1</span>,
        <span class="kw">&quot;</span><span class="st">group</span><span class="dt">$group</span><span class="kw">&quot;</span> =&gt; <span class="dv">1</span>,
        bias          =&gt; <span class="dv">1</span>,
    });
}

<span class="kw">sub </span><span class="fu">build_subgroup_samples</span> {
    <span class="kw">my</span> <span class="dt">$n</span> = <span class="fu">shift</span>;
    <span class="kw">my</span> (<span class="dt">$rate</span>, <span class="dt">$vec</span>) = build_subgroup <span class="dt">$n</span>;
    <span class="fu">map</span> {
        [<span class="dt">$vec</span>, <span class="dt">$_</span> &lt;= <span class="dt">$rate</span> ? <span class="dv">1</span> : <span class="dv">0</span>];
    } <span class="dv">1</span> .. <span class="dv">100</span>;
}

<span class="kw">my</span> <span class="dt">@all_samples</span> = <span class="fu">map</span> { build_subgroup_samples <span class="dt">$_</span> } <span class="dv">0</span> .. <span class="dv">9999</span>;

<span class="kw">my</span> <span class="dt">%weight</span>;
<span class="kw">for</span> (<span class="dv">1</span> .. <span class="dv">10</span>) {
    <span class="fu">print</span> <span class="kw">&quot;</span><span class="st">ITERATION </span><span class="dt">$_</span><span class="ch">\n</span><span class="kw">&quot;</span>;
    <span class="kw">my</span> <span class="dt">$eta</span> = <span class="fl">0.1</span> - <span class="fl">0.005</span> <span class="kw">*</span> <span class="dt">$_</span>;
    <span class="kw">for</span> (shuffle <span class="dt">@all_samples</span>) {
        <span class="kw">my</span> (<span class="dt">$vec</span>, <span class="dt">$t</span>) = <span class="dt">@$_</span>;
        train \<span class="dt">%weight</span>, <span class="dt">$vec</span>, <span class="dt">$t</span>, <span class="dt">$eta</span>;
    }
}

<span class="co"># Predict for groups</span>
<span class="kw">for</span> (<span class="dv">0</span> .. <span class="dv">9</span>) {
    <span class="fu">printf</span> <span class="kw">&quot;</span><span class="st">group=</span><span class="dt">%d</span><span class="st">, RATE=</span><span class="dt">%3</span><span class="st">.2f %%</span><span class="ch">\n</span><span class="kw">&quot;</span>, <span class="dt">$_</span>, <span class="dv">100</span> <span class="kw">*</span> (predict \<span class="dt">%weight</span>, {<span class="kw">&quot;</span><span class="st">group</span><span class="dt">$_</span><span class="kw">&quot;</span> =&gt; <span class="dv">1</span>, bias =&gt; <span class="dv">1</span>});
}

<span class="co"># Predict for subgroups</span>
<span class="kw">for</span> (<span class="dv">0</span> .. <span class="dv">9</span>) {
    <span class="kw">my</span> <span class="dt">$subgroup</span> = <span class="dt">$_</span> <span class="kw">*</span> <span class="dv">1000</span> + <span class="dv">1</span>;
    <span class="fu">printf</span> <span class="kw">&quot;</span><span class="st">subgroup=</span><span class="dt">%4d</span><span class="st">, RATE=</span><span class="dt">%3</span><span class="st">.2f %%</span><span class="ch">\n</span><span class="kw">&quot;</span>, <span class="dt">$subgroup</span>, <span class="dv">100</span> <span class="kw">*</span> (predict \<span class="dt">%weight</span>, {<span class="kw">&quot;</span><span class="st">subgroup</span><span class="dt">$subgroup</span><span class="kw">&quot;</span> =&gt; <span class="dv">1</span>, <span class="kw">&quot;</span><span class="st">group</span><span class="dt">$</span><span class="st">{\ group_of_subgroup </span><span class="dt">$subgroup</span><span class="st">}</span><span class="kw">&quot;</span> =&gt; <span class="dv">1</span>, bias =&gt; <span class="dv">1</span>});
}

<span class="co"># Predict for unknown subgroups</span>
<span class="fu">printf</span> <span class="kw">&quot;</span><span class="st">UNKNOWN RATE=</span><span class="dt">%3</span><span class="st">.2f %%</span><span class="ch">\n</span><span class="kw">&quot;</span>, <span class="dv">100</span> <span class="kw">*</span> (predict \<span class="dt">%weight</span>, {bias =&gt; <span class="dv">1</span>});
<span class="kw">__END__</span>
ITERATION <span class="dv">1</span>
ITERATION <span class="dv">2</span>
ITERATION <span class="dv">3</span>
ITERATION <span class="dv">4</span>
ITERATION <span class="dv">5</span>
ITERATION <span class="dv">6</span>
ITERATION <span class="dv">7</span>
ITERATION <span class="dv">8</span>
ITERATION <span class="dv">9</span>
ITERATION <span class="dv">10</span>
group=<span class="dv">0</span>, RATE=<span class="fl">1.19</span> %
group=<span class="dv">1</span>, RATE=<span class="fl">1.81</span> %
group=<span class="dv">2</span>, RATE=<span class="fl">3.58</span> %
group=<span class="dv">3</span>, RATE=<span class="fl">4.65</span> %
group=<span class="dv">4</span>, RATE=<span class="fl">4.66</span> %
group=<span class="dv">5</span>, RATE=<span class="fl">8.93</span> %
group=<span class="dv">6</span>, RATE=<span class="fl">7.78</span> %
group=<span class="dv">7</span>, RATE=<span class="fl">9.33</span> %
group=<span class="dv">8</span>, RATE=<span class="fl">9.75</span> %
group=<span class="dv">9</span>, RATE=<span class="fl">11.19</span> %
subgroup=   <span class="dv">1</span>, RATE=<span class="fl">1.19</span> %
subgroup=<span class="dv">1001</span>, RATE=<span class="fl">1.81</span> %
subgroup=<span class="dv">2001</span>, RATE=<span class="fl">3.56</span> %
subgroup=<span class="dv">3001</span>, RATE=<span class="fl">4.64</span> %
subgroup=<span class="dv">4001</span>, RATE=<span class="fl">4.63</span> %
subgroup=<span class="dv">5001</span>, RATE=<span class="fl">9.10</span> %
subgroup=<span class="dv">6001</span>, RATE=<span class="fl">7.80</span> %
subgroup=<span class="dv">7001</span>, RATE=<span class="fl">9.53</span> %
subgroup=<span class="dv">8001</span>, RATE=<span class="fl">9.87</span> %
subgroup=<span class="dv">9001</span>, RATE=<span class="fl">11.34</span> %
UNKNOWN RATE=<span class="fl">6.62</span> %</code></pre>
<p>ここで自分がひっかかっていたのが、説明変数に従属的な関係がある場合。 例えばこのコードだと、subgroupが決まるとgroupが自動的に決まるため、groupの値が一部死に体となる。 が、先ほど書いたようにパラメータ数より等式のほうが圧倒的に大きいので、一部が無視されても実際は問題とはならない。 例えば二次元の場合で第二要素が1の時は必ず第一要素が1となるという制約が入って <span class="math">\((0, 0), (1, 0), (1, 1)\)</span> の値しか 登場しないとしても、パラメータ3つに関して等式が3本となるので、パラメータを決定するには十分な情報がある。</p>
<p>もう一点、逐次学習するに当たって、学習データにおいてgroupの登場回数(1となっているベクトルの件数)が1つにつき10万回あるのに対し、subgroupの登場回数は100回なので、 subgroupについては十分に学習されないのではないかという懸念もあった。これも結果を見る限りは大丈夫そうだ。 登場回数は少なくても、目的変数が<span class="math">\(1\)</span>となった場合には現時点のズレを元に大きく重みが増えることを考えれば自然に思える。 また、登場回数が少ないということは目的変数が<span class="math">\(0\)</span>になって重みが減算される機会も少ないと言えそうだ。</p>

</div>



<div>
  <h1><a href="./posts/2014-04-17-multivariate_analysis.html">4/17の読書メモ:続微分積分読本</a></h1>

<div class="info">
    Posted on April 17, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-04-17-multivariate_analysis.html" data-text="4/17の読書メモ:続微分積分読本" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-04-17-multivariate_analysis.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<blockquote>
<p><a href="http://www.amazon.co.jp/%E7%B6%9A-%E5%BE%AE%E5%88%86%E7%A9%8D%E5%88%86%E8%AA%AD%E6%9C%AC-%E5%A4%9A%E5%A4%89%E6%95%B0-%E5%B0%8F%E6%9E%97-%E6%98%AD%E4%B8%83/dp/4785315261%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Ddays0aa-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4785315261" target="_top">続 微分積分読本 -多変数-</a><br />小林 昭七 <br /><a href="http://www.amazon.co.jp/%E7%B6%9A-%E5%BE%AE%E5%88%86%E7%A9%8D%E5%88%86%E8%AA%AD%E6%9C%AC-%E5%A4%9A%E5%A4%89%E6%95%B0-%E5%B0%8F%E6%9E%97-%E6%98%AD%E4%B8%83/dp/4785315261%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Ddays0aa-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4785315261" target="_top"><img src="http://ecx.images-amazon.com/images/I/4150MMH4WHL._SL75_.jpg" border="0" alt="4785315261" /></a><br /><img src="http://www.assoc-amazon.jp/e/ir?t=days0aa-22&amp;l=ur2&amp;o=9" width="1" height="1" style="border: none;" alt /></p>
</blockquote>
<h2 id="p.22p29-陰関数定理">p.22,p29 陰関数定理</h2>
<p>本書では定義域方向の区間<span class="math">\((x - b, x + b)\)</span>の存在も示しているが、これは不要に思える。有界域で定義された連続関数なのだから有界なのは当たり前なわけで。本質的に大事なのは、陽関数が一意に存在して<span class="math">\(C^1\)</span>級となることだろう。</p>
<h2 id="p.26-逆関数定理">p.26 逆関数定理</h2>
<p><span class="math">\(f(x) - x\)</span>に対して陰関数定理を使って<span class="math">\(x\)</span>について陽関数を得れば、逆関数定理を得られる。</p>

</div>



<div>
  <h1><a href="./posts/2014-04-10-multivariate_analysis.html">4/10の読書メモ:続微分積分読本</a></h1>

<div class="info">
    Posted on April 10, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-04-10-multivariate_analysis.html" data-text="4/10の読書メモ:続微分積分読本" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-04-10-multivariate_analysis.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<blockquote>
<p><a href="http://www.amazon.co.jp/%E7%B6%9A-%E5%BE%AE%E5%88%86%E7%A9%8D%E5%88%86%E8%AA%AD%E6%9C%AC-%E5%A4%9A%E5%A4%89%E6%95%B0-%E5%B0%8F%E6%9E%97-%E6%98%AD%E4%B8%83/dp/4785315261%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Ddays0aa-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4785315261" target="_top">続 微分積分読本 -多変数-</a><br />小林 昭七 <br /><a href="http://www.amazon.co.jp/%E7%B6%9A-%E5%BE%AE%E5%88%86%E7%A9%8D%E5%88%86%E8%AA%AD%E6%9C%AC-%E5%A4%9A%E5%A4%89%E6%95%B0-%E5%B0%8F%E6%9E%97-%E6%98%AD%E4%B8%83/dp/4785315261%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Ddays0aa-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4785315261" target="_top"><img src="http://ecx.images-amazon.com/images/I/4150MMH4WHL._SL75_.jpg" border="0" alt="4785315261" /></a><br /><img src="http://www.assoc-amazon.jp/e/ir?t=days0aa-22&amp;l=ur2&amp;o=9" width="1" height="1" style="border: none;" alt /></p>
</blockquote>
<h2 id="p.19-平均値定理">p.19 平均値定理</h2>
<p>２変数の場合、合成関数の微分と同様に<span class="math">\(f_x\)</span>か<span class="math">\(f_y\)</span>の連続を仮定する必要が出てくる。この辺は、<span class="math">\(f_x\)</span>によって<span class="math">\(x\)</span>についての性質は捉えられるが、<span class="math">\(y\)</span>についての性質は捉えられないってことかなと思う。驚くべきはむしろ<span class="math">\(f_x\)</span>と<span class="math">\(f_y\)</span>の片方の連続を仮定するだけでいいことだが、これはある点を基準とした時に<span class="math">\(x\)</span>か<span class="math">\(y\)</span>のどちらか片方の向きについてはもう片方の変数を全く動かさなくて住む、つまり１変数に帰着できるからかなと思う。証明を見ても、</p>
<p><span class="math">\[
\begin{align}
  &amp;  f(a + \Delta x, b + \Delta y) - f(a, b) \\
  &amp;= f(a + \Delta x, b + \Delta y) - f(a, b + \Delta y) + f(a, b + \Delta y) - f(a, b)
\end{align}
\]</span></p>
<p>という変形を使っていて、ここで最初の2項には固定したい<span class="math">\(y\)</span>側に<span class="math">\(\Delta y\)</span>がいるので、<span class="math">\(x\)</span>軸方向だけで議論を進めることができない。他方、最後の2項は<span class="math">\(y\)</span>方向にしか変化させないので1変数の条件によって各種定理が適用できる。</p>

</div>



<div>
  <h1><a href="./posts/2014-04-08-multivariate_analysis.html">4/8の読書メモ:続微分積分読本</a></h1>

<div class="info">
    Posted on April  8, 2014
    
    <!-- Twitter button -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="/posts/2014-04-08-multivariate_analysis.html" data-text="4/8の読書メモ:続微分積分読本" data-via="hiratara">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <!-- facebook button -->
    <div class="fb-like" data-href="/posts/2014-04-08-multivariate_analysis.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></div>
</div>

<blockquote>
<p><a href="http://www.amazon.co.jp/%E7%B6%9A-%E5%BE%AE%E5%88%86%E7%A9%8D%E5%88%86%E8%AA%AD%E6%9C%AC-%E5%A4%9A%E5%A4%89%E6%95%B0-%E5%B0%8F%E6%9E%97-%E6%98%AD%E4%B8%83/dp/4785315261%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Ddays0aa-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4785315261" target="_top">続 微分積分読本 -多変数-</a><br />小林 昭七 <br /><a href="http://www.amazon.co.jp/%E7%B6%9A-%E5%BE%AE%E5%88%86%E7%A9%8D%E5%88%86%E8%AA%AD%E6%9C%AC-%E5%A4%9A%E5%A4%89%E6%95%B0-%E5%B0%8F%E6%9E%97-%E6%98%AD%E4%B8%83/dp/4785315261%3FSubscriptionId%3D15SMZCTB9V8NGR2TW082%26tag%3Ddays0aa-22%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D4785315261" target="_top"><img src="http://ecx.images-amazon.com/images/I/4150MMH4WHL._SL75_.jpg" border="0" alt="4785315261" /></a><br /><img src="http://www.assoc-amazon.jp/e/ir?t=days0aa-22&amp;l=ur2&amp;o=9" width="1" height="1" style="border: none;" alt /></p>
</blockquote>
<h2 id="p.18-連鎖律">p.18 連鎖律</h2>
<p>2変数関数だと対象となる関数の偏微分<span class="math">\(f_x\)</span>または<span class="math">\(f_y\)</span>のどちらかが連続でないと合成関数の偏微分公式が成り立たない。</p>
<p>ここで気がついたのだけど、p.14で方向微分を偏微分で表す場合にも、同じ仮定が必要なようだ。</p>

</div>



<p>…or you can find more in the <a href="./archive.html">archives</a>.

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
